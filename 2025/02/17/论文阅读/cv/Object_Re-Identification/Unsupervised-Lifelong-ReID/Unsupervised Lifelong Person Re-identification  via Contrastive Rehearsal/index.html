<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blueeemouse.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="arxiv 22 这篇论文提出的设定倒是在现实生活里有意义，不过它的动机好像也是提的比较模糊，都是针对几个设定加起来的时候产生的问题 它讲的故事：However, a real-world video monitoring system can record new data every day and from new locations, when new cameras are ad">
<meta property="og:type" content="article">
<meta property="og:title" content="bluemouse&#39;s blog">
<meta property="og:url" content="https://blueeemouse.github.io/2025/02/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/cv/Object_Re-Identification/Unsupervised-Lifelong-ReID/Unsupervised%20Lifelong%20Person%20Re-identification%20%20via%20Contrastive%20Rehearsal/index.html">
<meta property="og:site_name" content="bluemouse&#39;s blog">
<meta property="og:description" content="arxiv 22 这篇论文提出的设定倒是在现实生活里有意义，不过它的动机好像也是提的比较模糊，都是针对几个设定加起来的时候产生的问题 它讲的故事：However, a real-world video monitoring system can record new data every day and from new locations, when new cameras are ad">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-02-17T14:22:45.536Z">
<meta property="article:modified_time" content="2025-02-17T15:22:13.383Z">
<meta property="article:author" content="bluemouse">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blueeemouse.github.io/2025/02/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/cv/Object_Re-Identification/Unsupervised-Lifelong-ReID/Unsupervised%20Lifelong%20Person%20Re-identification%20%20via%20Contrastive%20Rehearsal/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title> | bluemouse's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bluemouse's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueeemouse.github.io/2025/02/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/cv/Object_Re-Identification/Unsupervised-Lifelong-ReID/Unsupervised%20Lifelong%20Person%20Re-identification%20%20via%20Contrastive%20Rehearsal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-02-17 22:22:45 / Modified: 23:22:13" itemprop="dateCreated datePublished" datetime="2025-02-17T22:22:45+08:00">2025-02-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="arxiv-22">arxiv 22</h1>
<h1
id="这篇论文提出的设定倒是在现实生活里有意义不过它的动机好像也是提的比较模糊都是针对几个设定加起来的时候产生的问题">这篇论文提出的设定倒是在现实生活里有意义，不过它的动机好像也是提的比较模糊，都是针对几个设定加起来的时候产生的问题</h1>
<h1
id="它讲的故事however-a-real-world-video-monitoring-system-can-record-new-data-every-day-and-from-new-locations-when-new-cameras-are-added-into-an-existing-system.when-new-data-is-recorded-every-day-people-have-to-annotate-new-data-manually-before-deployment-which-is-cumbersome-and-time-consuming.这里在说明无监督方法研究的必要性-towards-a-generalizable-reid-model-lifelong-person-reid-has-been-recently-proposed这里在说明lifelong-learning研究的必要性">它讲的故事：However,
a real-world video monitoring system can record new data every day and
from new locations, when new cameras are added into an existing
system.；When new data is recorded every day, people have to annotate
new data manually before deployment, which is cumbersome and
time-consuming.（这里在说明，无监督方法研究的必要性）<br>Towards a
generalizable ReID model, lifelong person ReID has been recently
proposed（这里在说明，lifelong learning研究的必要性）</h1>
<h1
id="它的方法设计的倒也算简单就是分别针对灾难性遗忘学习新数据的问题">它的方法，设计的倒也算简单，就是分别针对灾难性遗忘、学习新数据的问题</h1>
<h1 id="方法">方法</h1>
<h2 id="current-domain-contrastive-baseline">1.Current domain
contrastive baseline</h2>
<h3
id="它主要是进行经典的拉近样本和簇中心的距离如今已经是一个非常常见的操作了还有一个l_cam就是对同一个簇里属于同一个相机的数据也求一个prototype就是这些数据的均值并要拉近样本与这个prototype的距离还是对比损失的形式">它主要是进行经典的拉近样本和簇中心的距离（如今已经是一个非常常见的操作了），还有一个<span
class="math inline">\(L_{cam}\)</span>，就是对同一个簇里，属于同一个相机的数据，也求一个prototype（就是这些数据的均值），并要拉近样本与这个prototype的距离（还是对比损失的形式）</h3>
<h4
id="不过论文里还提到l_cam过于依赖相机标签局限在了reid任务里了如果想更加泛化其实也有其它的损失可以用比如在一个batch里与batch里的hardest-positives进行对比">不过，论文里还提到，<span
class="math inline">\(L_{cam}\)</span>过于依赖相机标签，局限在了ReID任务里了；如果想更加泛化，其实也有其它的损失可以用，比如在一个batch里，与batch里的hardest
positives进行对比</h4>
<h4
id="另注意这个方法会有online-encoder和momentum-encoder在这一步里聚类用的特征是momentum-encoder得到的而不是online-encoder">（另，注意，这个方法会有online
encoder和momentum encoder；在这一步里，聚类用的特征是momentum
encoder得到的，而不是online encoder）</h4>
<h2 id="old-domain-contrastive-rehearsal">2.Old domain contrastive
rehearsal</h2>
<h3
id="这个方法里会存储一些旧数据集的prototype也就是我们得到的簇中心的特征以及各个簇的若干个可靠样本就是比较接近簇中心的这一步的核心思想是给定一个已知伪标签的旧数据样本我们希望当前的online-encoder对其编码后得到的特征应该还是尽可能接近原来它所属的那个簇由此我们认为online-encoder对旧数据集知识的保存做的比较好">这个方法里会存储一些旧数据集的prototype（也就是我们得到的簇中心的特征），以及各个簇的若干个可靠样本（就是比较接近簇中心的）。这一步的核心思想是，给定一个已知伪标签的旧数据样本，我们希望当前的online
encoder对其编码后，得到的特征应该还是尽可能接近原来它所属的那个簇（由此我们认为online
encoder对旧数据集知识的保存做的比较好）</h3>
<h2 id="image-to-image-similarity-constraint">3.Image-to-Image
Similarity Constraint</h2>
<h3
id="这一步的作用是抗遗忘然后它的核心思想是给定一个batch我们用encoder得到特征后可以得到一个样本之间的相似性矩阵如果新模型得到的相似性矩阵与旧模型得到的相似性矩阵很接近对于同一个batch而言那么我们就认为这个新模型保留旧知识时保留得比较好论文里新模型就对应online-encoder旧模型就对应momentum-encoder它保留了比较多的旧知识衡量两个相似性矩阵的距离时用的是kl散度">这一步的作用是抗遗忘，然后它的核心思想是，给定一个batch，我们用encoder得到特征后，可以得到一个样本之间的相似性矩阵。如果新模型得到的相似性矩阵与旧模型得到的相似性矩阵很接近（对于同一个batch而言），那么我们就认为这个新模型保留旧知识时，保留得比较好。论文里，新模型就对应online
encoder，旧模型就对应momentum
encoder（它保留了比较多的旧知识）。衡量两个相似性矩阵的距离时，用的是KL散度</h3>
<h3
id="但此处有个小改进就是它的目标矩阵确实是用旧模型得到的但它的新的相似性矩阵计算的时候求行特征用的是新模型求列特征用的是旧模型论文里说这样的效果比单纯用新模型会好确实有一些道理吧因为求列特征用的是旧模型那么要迫使两个相似性矩阵尽可能接近就要求新模型的输出要尽可能接近旧模型的输出无形中其实就进行了蒸馏了吧">但此处有个小改进，就是，它的目标矩阵确实是用旧模型得到的，但它的新的相似性矩阵，计算的时候，求行特征用的是新模型，求列特征用的是旧模型。论文里说这样的效果比单纯用新模型会好。确实有一些道理吧，因为求列特征用的是旧模型，那么，要迫使两个相似性矩阵尽可能接近，就要求新模型的输出要尽可能接近旧模型的输出（无形中其实就进行了蒸馏了吧）</h3>
<h1 id="trick总结">trick总结</h1>
<h2
id="在进行对比的时候既可以和所有的prototype来对比也可以挑出若干个hard-sample保证效果的同时减少一些计算量">1.在进行对比的时候，既可以和所有的prototype来对比，也可以挑出若干个hard
sample，保证效果的同时减少一些计算量</h2>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/02/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/cv/Object_Re-Identification/Unsupervised-VI-ReID/Robust%20Pseudo-label%20Learning%20with%20Neighbor%20Relation%20for%20Unsupervised%20Visible-Infrared%20Person%20Re-Identification/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/02/18/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/cv/Object_Re-Identification/Unsupervised-Lifelong-VI-ReID/motivation/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#arxiv-22"><span class="nav-number">1.</span> <span class="nav-text">arxiv 22</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%99%E7%AF%87%E8%AE%BA%E6%96%87%E6%8F%90%E5%87%BA%E7%9A%84%E8%AE%BE%E5%AE%9A%E5%80%92%E6%98%AF%E5%9C%A8%E7%8E%B0%E5%AE%9E%E7%94%9F%E6%B4%BB%E9%87%8C%E6%9C%89%E6%84%8F%E4%B9%89%E4%B8%8D%E8%BF%87%E5%AE%83%E7%9A%84%E5%8A%A8%E6%9C%BA%E5%A5%BD%E5%83%8F%E4%B9%9F%E6%98%AF%E6%8F%90%E7%9A%84%E6%AF%94%E8%BE%83%E6%A8%A1%E7%B3%8A%E9%83%BD%E6%98%AF%E9%92%88%E5%AF%B9%E5%87%A0%E4%B8%AA%E8%AE%BE%E5%AE%9A%E5%8A%A0%E8%B5%B7%E6%9D%A5%E7%9A%84%E6%97%B6%E5%80%99%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">这篇论文提出的设定倒是在现实生活里有意义，不过它的动机好像也是提的比较模糊，都是针对几个设定加起来的时候产生的问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%83%E8%AE%B2%E7%9A%84%E6%95%85%E4%BA%8Bhowever-a-real-world-video-monitoring-system-can-record-new-data-every-day-and-from-new-locations-when-new-cameras-are-added-into-an-existing-system.when-new-data-is-recorded-every-day-people-have-to-annotate-new-data-manually-before-deployment-which-is-cumbersome-and-time-consuming.%E8%BF%99%E9%87%8C%E5%9C%A8%E8%AF%B4%E6%98%8E%E6%97%A0%E7%9B%91%E7%9D%A3%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7-towards-a-generalizable-reid-model-lifelong-person-reid-has-been-recently-proposed%E8%BF%99%E9%87%8C%E5%9C%A8%E8%AF%B4%E6%98%8Elifelong-learning%E7%A0%94%E7%A9%B6%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">它讲的故事：However,
a real-world video monitoring system can record new data every day and
from new locations, when new cameras are added into an existing
system.；When new data is recorded every day, people have to annotate
new data manually before deployment, which is cumbersome and
time-consuming.（这里在说明，无监督方法研究的必要性）Towards a
generalizable ReID model, lifelong person ReID has been recently
proposed（这里在说明，lifelong learning研究的必要性）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%83%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%80%92%E4%B9%9F%E7%AE%97%E7%AE%80%E5%8D%95%E5%B0%B1%E6%98%AF%E5%88%86%E5%88%AB%E9%92%88%E5%AF%B9%E7%81%BE%E9%9A%BE%E6%80%A7%E9%81%97%E5%BF%98%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">它的方法，设计的倒也算简单，就是分别针对灾难性遗忘、学习新数据的问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#current-domain-contrastive-baseline"><span class="nav-number">5.1.</span> <span class="nav-text">1.Current domain
contrastive baseline</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%83%E4%B8%BB%E8%A6%81%E6%98%AF%E8%BF%9B%E8%A1%8C%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8B%89%E8%BF%91%E6%A0%B7%E6%9C%AC%E5%92%8C%E7%B0%87%E4%B8%AD%E5%BF%83%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%A6%82%E4%BB%8A%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E4%BA%86%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AAl_cam%E5%B0%B1%E6%98%AF%E5%AF%B9%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B0%87%E9%87%8C%E5%B1%9E%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E7%9B%B8%E6%9C%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B9%9F%E6%B1%82%E4%B8%80%E4%B8%AAprototype%E5%B0%B1%E6%98%AF%E8%BF%99%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9D%87%E5%80%BC%E5%B9%B6%E8%A6%81%E6%8B%89%E8%BF%91%E6%A0%B7%E6%9C%AC%E4%B8%8E%E8%BF%99%E4%B8%AAprototype%E7%9A%84%E8%B7%9D%E7%A6%BB%E8%BF%98%E6%98%AF%E5%AF%B9%E6%AF%94%E6%8D%9F%E5%A4%B1%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="nav-number">5.1.1.</span> <span class="nav-text">它主要是进行经典的拉近样本和簇中心的距离（如今已经是一个非常常见的操作了），还有一个\(L_{cam}\)，就是对同一个簇里，属于同一个相机的数据，也求一个prototype（就是这些数据的均值），并要拉近样本与这个prototype的距离（还是对比损失的形式）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%BF%87%E8%AE%BA%E6%96%87%E9%87%8C%E8%BF%98%E6%8F%90%E5%88%B0l_cam%E8%BF%87%E4%BA%8E%E4%BE%9D%E8%B5%96%E7%9B%B8%E6%9C%BA%E6%A0%87%E7%AD%BE%E5%B1%80%E9%99%90%E5%9C%A8%E4%BA%86reid%E4%BB%BB%E5%8A%A1%E9%87%8C%E4%BA%86%E5%A6%82%E6%9E%9C%E6%83%B3%E6%9B%B4%E5%8A%A0%E6%B3%9B%E5%8C%96%E5%85%B6%E5%AE%9E%E4%B9%9F%E6%9C%89%E5%85%B6%E5%AE%83%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%AF%94%E5%A6%82%E5%9C%A8%E4%B8%80%E4%B8%AAbatch%E9%87%8C%E4%B8%8Ebatch%E9%87%8C%E7%9A%84hardest-positives%E8%BF%9B%E8%A1%8C%E5%AF%B9%E6%AF%94"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">不过，论文里还提到，\(L_{cam}\)过于依赖相机标签，局限在了ReID任务里了；如果想更加泛化，其实也有其它的损失可以用，比如在一个batch里，与batch里的hardest
positives进行对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%A6%E6%B3%A8%E6%84%8F%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E4%BC%9A%E6%9C%89online-encoder%E5%92%8Cmomentum-encoder%E5%9C%A8%E8%BF%99%E4%B8%80%E6%AD%A5%E9%87%8C%E8%81%9A%E7%B1%BB%E7%94%A8%E7%9A%84%E7%89%B9%E5%BE%81%E6%98%AFmomentum-encoder%E5%BE%97%E5%88%B0%E7%9A%84%E8%80%8C%E4%B8%8D%E6%98%AFonline-encoder"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">（另，注意，这个方法会有online
encoder和momentum encoder；在这一步里，聚类用的特征是momentum
encoder得到的，而不是online encoder）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#old-domain-contrastive-rehearsal"><span class="nav-number">5.2.</span> <span class="nav-text">2.Old domain contrastive
rehearsal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E9%87%8C%E4%BC%9A%E5%AD%98%E5%82%A8%E4%B8%80%E4%BA%9B%E6%97%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84prototype%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E5%BE%97%E5%88%B0%E7%9A%84%E7%B0%87%E4%B8%AD%E5%BF%83%E7%9A%84%E7%89%B9%E5%BE%81%E4%BB%A5%E5%8F%8A%E5%90%84%E4%B8%AA%E7%B0%87%E7%9A%84%E8%8B%A5%E5%B9%B2%E4%B8%AA%E5%8F%AF%E9%9D%A0%E6%A0%B7%E6%9C%AC%E5%B0%B1%E6%98%AF%E6%AF%94%E8%BE%83%E6%8E%A5%E8%BF%91%E7%B0%87%E4%B8%AD%E5%BF%83%E7%9A%84%E8%BF%99%E4%B8%80%E6%AD%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E6%98%AF%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%9F%A5%E4%BC%AA%E6%A0%87%E7%AD%BE%E7%9A%84%E6%97%A7%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%AC%E6%88%91%E4%BB%AC%E5%B8%8C%E6%9C%9B%E5%BD%93%E5%89%8D%E7%9A%84online-encoder%E5%AF%B9%E5%85%B6%E7%BC%96%E7%A0%81%E5%90%8E%E5%BE%97%E5%88%B0%E7%9A%84%E7%89%B9%E5%BE%81%E5%BA%94%E8%AF%A5%E8%BF%98%E6%98%AF%E5%B0%BD%E5%8F%AF%E8%83%BD%E6%8E%A5%E8%BF%91%E5%8E%9F%E6%9D%A5%E5%AE%83%E6%89%80%E5%B1%9E%E7%9A%84%E9%82%A3%E4%B8%AA%E7%B0%87%E7%94%B1%E6%AD%A4%E6%88%91%E4%BB%AC%E8%AE%A4%E4%B8%BAonline-encoder%E5%AF%B9%E6%97%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9F%A5%E8%AF%86%E7%9A%84%E4%BF%9D%E5%AD%98%E5%81%9A%E7%9A%84%E6%AF%94%E8%BE%83%E5%A5%BD"><span class="nav-number">5.2.1.</span> <span class="nav-text">这个方法里会存储一些旧数据集的prototype（也就是我们得到的簇中心的特征），以及各个簇的若干个可靠样本（就是比较接近簇中心的）。这一步的核心思想是，给定一个已知伪标签的旧数据样本，我们希望当前的online
encoder对其编码后，得到的特征应该还是尽可能接近原来它所属的那个簇（由此我们认为online
encoder对旧数据集知识的保存做的比较好）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#image-to-image-similarity-constraint"><span class="nav-number">5.3.</span> <span class="nav-text">3.Image-to-Image
Similarity Constraint</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%99%E4%B8%80%E6%AD%A5%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E6%8A%97%E9%81%97%E5%BF%98%E7%84%B6%E5%90%8E%E5%AE%83%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E6%98%AF%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AAbatch%E6%88%91%E4%BB%AC%E7%94%A8encoder%E5%BE%97%E5%88%B0%E7%89%B9%E5%BE%81%E5%90%8E%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%A0%B7%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BC%BC%E6%80%A7%E7%9F%A9%E9%98%B5%E5%A6%82%E6%9E%9C%E6%96%B0%E6%A8%A1%E5%9E%8B%E5%BE%97%E5%88%B0%E7%9A%84%E7%9B%B8%E4%BC%BC%E6%80%A7%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%97%A7%E6%A8%A1%E5%9E%8B%E5%BE%97%E5%88%B0%E7%9A%84%E7%9B%B8%E4%BC%BC%E6%80%A7%E7%9F%A9%E9%98%B5%E5%BE%88%E6%8E%A5%E8%BF%91%E5%AF%B9%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AAbatch%E8%80%8C%E8%A8%80%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E5%B0%B1%E8%AE%A4%E4%B8%BA%E8%BF%99%E4%B8%AA%E6%96%B0%E6%A8%A1%E5%9E%8B%E4%BF%9D%E7%95%99%E6%97%A7%E7%9F%A5%E8%AF%86%E6%97%B6%E4%BF%9D%E7%95%99%E5%BE%97%E6%AF%94%E8%BE%83%E5%A5%BD%E8%AE%BA%E6%96%87%E9%87%8C%E6%96%B0%E6%A8%A1%E5%9E%8B%E5%B0%B1%E5%AF%B9%E5%BA%94online-encoder%E6%97%A7%E6%A8%A1%E5%9E%8B%E5%B0%B1%E5%AF%B9%E5%BA%94momentum-encoder%E5%AE%83%E4%BF%9D%E7%95%99%E4%BA%86%E6%AF%94%E8%BE%83%E5%A4%9A%E7%9A%84%E6%97%A7%E7%9F%A5%E8%AF%86%E8%A1%A1%E9%87%8F%E4%B8%A4%E4%B8%AA%E7%9B%B8%E4%BC%BC%E6%80%A7%E7%9F%A9%E9%98%B5%E7%9A%84%E8%B7%9D%E7%A6%BB%E6%97%B6%E7%94%A8%E7%9A%84%E6%98%AFkl%E6%95%A3%E5%BA%A6"><span class="nav-number">5.3.1.</span> <span class="nav-text">这一步的作用是抗遗忘，然后它的核心思想是，给定一个batch，我们用encoder得到特征后，可以得到一个样本之间的相似性矩阵。如果新模型得到的相似性矩阵与旧模型得到的相似性矩阵很接近（对于同一个batch而言），那么我们就认为这个新模型保留旧知识时，保留得比较好。论文里，新模型就对应online
encoder，旧模型就对应momentum
encoder（它保留了比较多的旧知识）。衡量两个相似性矩阵的距离时，用的是KL散度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%86%E6%AD%A4%E5%A4%84%E6%9C%89%E4%B8%AA%E5%B0%8F%E6%94%B9%E8%BF%9B%E5%B0%B1%E6%98%AF%E5%AE%83%E7%9A%84%E7%9B%AE%E6%A0%87%E7%9F%A9%E9%98%B5%E7%A1%AE%E5%AE%9E%E6%98%AF%E7%94%A8%E6%97%A7%E6%A8%A1%E5%9E%8B%E5%BE%97%E5%88%B0%E7%9A%84%E4%BD%86%E5%AE%83%E7%9A%84%E6%96%B0%E7%9A%84%E7%9B%B8%E4%BC%BC%E6%80%A7%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97%E7%9A%84%E6%97%B6%E5%80%99%E6%B1%82%E8%A1%8C%E7%89%B9%E5%BE%81%E7%94%A8%E7%9A%84%E6%98%AF%E6%96%B0%E6%A8%A1%E5%9E%8B%E6%B1%82%E5%88%97%E7%89%B9%E5%BE%81%E7%94%A8%E7%9A%84%E6%98%AF%E6%97%A7%E6%A8%A1%E5%9E%8B%E8%AE%BA%E6%96%87%E9%87%8C%E8%AF%B4%E8%BF%99%E6%A0%B7%E7%9A%84%E6%95%88%E6%9E%9C%E6%AF%94%E5%8D%95%E7%BA%AF%E7%94%A8%E6%96%B0%E6%A8%A1%E5%9E%8B%E4%BC%9A%E5%A5%BD%E7%A1%AE%E5%AE%9E%E6%9C%89%E4%B8%80%E4%BA%9B%E9%81%93%E7%90%86%E5%90%A7%E5%9B%A0%E4%B8%BA%E6%B1%82%E5%88%97%E7%89%B9%E5%BE%81%E7%94%A8%E7%9A%84%E6%98%AF%E6%97%A7%E6%A8%A1%E5%9E%8B%E9%82%A3%E4%B9%88%E8%A6%81%E8%BF%AB%E4%BD%BF%E4%B8%A4%E4%B8%AA%E7%9B%B8%E4%BC%BC%E6%80%A7%E7%9F%A9%E9%98%B5%E5%B0%BD%E5%8F%AF%E8%83%BD%E6%8E%A5%E8%BF%91%E5%B0%B1%E8%A6%81%E6%B1%82%E6%96%B0%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BE%93%E5%87%BA%E8%A6%81%E5%B0%BD%E5%8F%AF%E8%83%BD%E6%8E%A5%E8%BF%91%E6%97%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BE%93%E5%87%BA%E6%97%A0%E5%BD%A2%E4%B8%AD%E5%85%B6%E5%AE%9E%E5%B0%B1%E8%BF%9B%E8%A1%8C%E4%BA%86%E8%92%B8%E9%A6%8F%E4%BA%86%E5%90%A7"><span class="nav-number">5.3.2.</span> <span class="nav-text">但此处有个小改进，就是，它的目标矩阵确实是用旧模型得到的，但它的新的相似性矩阵，计算的时候，求行特征用的是新模型，求列特征用的是旧模型。论文里说这样的效果比单纯用新模型会好。确实有一些道理吧，因为求列特征用的是旧模型，那么，要迫使两个相似性矩阵尽可能接近，就要求新模型的输出要尽可能接近旧模型的输出（无形中其实就进行了蒸馏了吧）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#trick%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">trick总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%AF%B9%E6%AF%94%E7%9A%84%E6%97%B6%E5%80%99%E6%97%A2%E5%8F%AF%E4%BB%A5%E5%92%8C%E6%89%80%E6%9C%89%E7%9A%84prototype%E6%9D%A5%E5%AF%B9%E6%AF%94%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%8C%91%E5%87%BA%E8%8B%A5%E5%B9%B2%E4%B8%AAhard-sample%E4%BF%9D%E8%AF%81%E6%95%88%E6%9E%9C%E7%9A%84%E5%90%8C%E6%97%B6%E5%87%8F%E5%B0%91%E4%B8%80%E4%BA%9B%E8%AE%A1%E7%AE%97%E9%87%8F"><span class="nav-number">6.1.</span> <span class="nav-text">1.在进行对比的时候，既可以和所有的prototype来对比，也可以挑出若干个hard
sample，保证效果的同时减少一些计算量</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bluemouse</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">131</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bluemouse</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
