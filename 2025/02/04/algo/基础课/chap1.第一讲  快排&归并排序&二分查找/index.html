<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blueeemouse.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1.快速排序 1.1.核心思想：分治思想 1.2.步骤： 1.2.1.对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边&#x2F;右边&#x2F;中间值&#x2F;随机选">
<meta property="og:type" content="article">
<meta property="og:title" content="chap1.第一讲 快排&amp;归并排序&amp;二分查找">
<meta property="og:url" content="https://blueeemouse.github.io/2025/02/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap1.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E5%BF%AB%E6%8E%92&%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/index.html">
<meta property="og:site_name" content="bluemouse&#39;s blog">
<meta property="og:description" content="1.快速排序 1.1.核心思想：分治思想 1.2.步骤： 1.2.1.对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边&#x2F;右边&#x2F;中间值&#x2F;随机选">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-02-04T08:00:00.000Z">
<meta property="article:modified_time" content="2025-04-13T13:15:25.503Z">
<meta property="article:author" content="bluemouse">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blueeemouse.github.io/2025/02/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap1.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E5%BF%AB%E6%8E%92&%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>chap1.第一讲 快排&归并排序&二分查找 | bluemouse's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bluemouse's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueeemouse.github.io/2025/02/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap1.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E5%BF%AB%E6%8E%92&%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          chap1.第一讲 快排&归并排序&二分查找
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-04 16:00:00" itemprop="dateCreated datePublished" datetime="2025-02-04T16:00:00+08:00">2025-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-13 21:15:25" itemprop="dateModified" datetime="2025-04-13T21:15:25+08:00">2025-04-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algo/" itemprop="url" rel="index"><span itemprop="name">algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="快速排序">1.快速排序</h1>
<h2 id="核心思想分治思想">1.1.核心思想：分治思想</h2>
<h2 id="步骤">1.2.步骤：</h2>
<h3
id="对于一个给定的数组选定一个中间值x理论上来说选哪个都行但后面的代码需要注意相应的搭配否则会陷入死循环后面具体讲常见的就是选数组的左边右边中间值随机选">1.2.1.对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边/右边/中间值/随机选</h3>
<span id="more"></span>
<h3
id="调整区间这一步的目的是调整数组使得数组的左边部分的元素全都小于等于中间值x右边部分的元素全都大于等于x此时一定有右边的元素大于等于左边的元素这是快排正确性的保证">1.2.2.调整区间：这一步的目的是，调整数组，使得数组的左边部分的元素全都小于等于中间值x，右边部分的元素全都大于等于x（此时，一定有右边的元素大于等于左边的元素。这是快排正确性的保证）</h3>
<h3
id="递归对上面的左边和右边部分的子数组也进行1.2.1-1.2.2的操作">1.2.3.递归：对上面的左边和右边部分的子数组也进行1.2.1-1.2.2的操作</h3>
<h3
id="可以看到核心步骤应该是1.2.2而关于1.2.2的实现一个比较简单粗暴的方法是再开两个数组ab然后从左到右扫描一遍待排序的数组s如果一个元素小于等于中间值则放到数组a里大于中间值则放到b里扫描完之后先把a的元素放回s里再把b的元素放回s里放回去的顺序也从左往右即可就完成了时间复杂度上因为要扫描一遍放回一遍应该是2n也就是on主要的问题在空间复杂度上需要再开两个数组不太好">可以看到，核心步骤应该是1.2.2。而关于1.2.2的实现，一个比较简单粗暴的方法是，再开两个数组a，b，然后，从左到右扫描一遍待排序的数组s，如果一个元素小于等于中间值，则放到数组a里，大于中间值，则放到b里。扫描完之后，先把a的元素放回s里，再把b的元素放回s里（放回去的顺序也从左往右即可），就完成了。时间复杂度上，因为要扫描一遍，放回一遍，应该是2N，也就是<span
class="math inline">\(O(N)\)</span>；主要的问题在空间复杂度上，需要再开两个数组，不太好</h3>
<h3
id="而我个人的第一想法是本质也是一个双指针法">而我个人的第一想法是，（本质也是一个双指针法）</h3>
<h4
id="给一组双指针起始分别在s的最左边和最右边">给一组双指针，起始分别在s的最左边和最右边。</h4>
<h4
id="左指针从左往右移动如果当前左指针指向的元素小于等于中间值x则不动它继续往右走一格如果当前左指针指向的元素大于中间值x则把它和s的右指针指向的元素替换同时右指针往左走一格左指针先不动换过来的新元素如果小于等于x则左指针往右走一格如果换过来的新元素还是大于x则再让它和右指针指向的元素交换一下注意上面已经让右指针往左走一格了">左指针从左往右移动，如果当前左指针指向的元素小于等于中间值x，则不动它，继续往右走一格；如果当前左指针指向的元素大于中间值x，则把它和s的右指针指向的元素替换，同时右指针往左走一格，左指针先不动：换过来的新元素如果小于等于x，则左指针往右走一格；如果换过来的新元素还是大于x，则再让它和右指针指向的元素交换一下（注意，上面已经让右指针往左走一格了），</h4>
<h4
id="然后一直重复上面的判断直到左指针继续往右走了或者是右指针一直往左走走到了与左指针相遇的位置感觉其实已经很接近给的模板了">然后一直重复上面的判断，直到左指针继续往右走了，或者是右指针一直往左走，走到了与左指针相遇的位置（感觉其实已经很接近给的模板了）</h4>
<h3
id="模板的话是一个双指针比我的稍微简洁一点主要的改进在于我的方法在遇到左指针元素大于x的时候一定会和右指针元素交换且右指针一定往走一格而模板的方法是">模板的话，是一个双指针，比我的稍微简洁一点。主要的改进在于，我的方法在遇到左指针元素大于x的时候，一定会和右指针元素交换，且右指针一定往走一格；而模板的方法是，</h3>
<h4
id="如果左指针元素小于x则符合要求左指针往右走一格如果左指针元素大于等于x则我不动左指针了去移动右指针如果右指针元素大于x也符合要求则右指针往左走一格如果右指针元素小于等于x则现在的情况是左指针元素大于等于x右指针元素小于等于x它们交换一下就刚好符合要求了故交换左右指针指向的元素之后继续移动左指针重复上面的步骤直至左右指针相遇或者右指针第一次走到左指针左边左指针第一次走到右指针右边代码模板如下">如果左指针元素小于x，则符合要求，左指针往右走一格；如果左指针元素大于等于x，则我不动左指针了，去移动右指针：如果右指针元素大于x，也符合要求，则右指针往左走一格；如果右指针元素小于等于x，则现在的情况是：左指针元素大于等于x，右指针元素小于等于x，它们交换一下就刚好符合要求了，故交换左右指针指向的元素。之后继续移动左指针，重复上面的步骤，直至左右指针相遇（或者右指针第一次走到左指针左边/左指针第一次走到右指针右边）。代码模板如下：</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>
<h2
id="问题模板变化的原理是就是说如果后面递归的时候用i来划分边界quick_sortq-l-i---1-quick_sortq-i-r则上面选枢纽元的时候不能选ql类似的用j来划分边界的时候枢纽元就不能取qr为什么">问题：模板变化的原理是？就是说，如果后面递归的时候，用i来划分边界，quick_sort(q,
l, i - 1), quick_sort(q, i,
r)，则上面选枢纽元的时候不能选q[l]？类似的，用j来划分边界的时候，枢纽元就不能取q[r]？为什么？</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误典范一：两个子while循环的判断条件中，带上了“等于”</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pivot = arr[mid];</span><br><span class="line">    <span class="comment">// int i = l - 1, j = r + 1;</span></span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; i &lt;&lt; j;</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; j;</span></span><br><span class="line">        <span class="comment">// i++;        // 看起来，似乎不在里面的两个while循环前移动指针，也不会有什么问题，因为：</span></span><br><span class="line">        <span class="comment">// 一个大的while循环结束之后，左右指针指向的元素应该都是符合要求的（左指针元素大于等于</span></span><br><span class="line">        <span class="comment">// pivot，右指针元素小于等于pivot）。此时开始一个新的while大循环，并不会有什么问题，在</span></span><br><span class="line">        <span class="comment">// 两个小的while循环中，应该会正常的通过，然后相应移动指针。。。</span></span><br><span class="line">        <span class="comment">// 但问题就是出在我们认为的“应该会正常通过”。事实上，一个大循环完了，确实左右指针的元素</span></span><br><span class="line">        <span class="comment">// 符合要求，但未必就能进到两个小的while循环里。</span></span><br><span class="line">        <span class="comment">// 这是因为，如果某个时刻出现：左右指针指向</span></span><br><span class="line">        <span class="comment">// 的元素都是pivot，则两个while都不会执行，swap也不会产生什么效果，然后再进到新的</span></span><br><span class="line">        <span class="comment">// while(i &lt; j)的循环中时，也是如此。就一直卡这里了，所以会超时</span></span><br><span class="line">        <span class="comment">// 说到底，其实是因为我们的两个子循环的判断条件导致的：都是严格的小于/大于，而不是</span></span><br><span class="line">        <span class="comment">// 小于等于/大于等于</span></span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) i++;       <span class="comment">// 像现在这样，判断条件中加上等于的话，</span></span><br><span class="line">        <span class="comment">// 看起来没什么问题，可如果出现一个数组里所有元素相等的极端情况的话，最终i就会变成r，</span></span><br><span class="line">        <span class="comment">// j也还是r不变，则下面的两个递归调用中，第一个就和现在的是一样的了，所以会一直递归调用</span></span><br><span class="line">        <span class="comment">// 陷入死循环</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; i;</span></span><br><span class="line">        <span class="comment">// j--;</span></span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; j &gt; i) j--;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; j;</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误典范二：在两个子while循环中不先移动一下指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pivot = arr[mid];</span><br><span class="line">    <span class="comment">// int i = l - 1, j = r + 1;</span></span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; i &lt;&lt; j;</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; j;</span></span><br><span class="line">        <span class="comment">// i++;        // 看起来，似乎不在里面的两个while循环前移动指针，也不会有什么问题，因为：</span></span><br><span class="line">        <span class="comment">// 一个大的while循环结束之后，左右指针指向的元素应该都是符合要求的（左指针元素大于等于</span></span><br><span class="line">        <span class="comment">// pivot，右指针元素小于等于pivot）。此时开始一个新的while大循环，并不会有什么问题，在</span></span><br><span class="line">        <span class="comment">// 两个小的while循环中，应该会正常的通过，然后相应移动指针。。。</span></span><br><span class="line">        <span class="comment">// 但问题就是出在我们认为的“应该会正常通过”。事实上，一个大循环完了，确实左右指针的元素</span></span><br><span class="line">        <span class="comment">// 符合要求，但未必就能进到两个小的while循环里。</span></span><br><span class="line">        <span class="comment">// 这是因为，如果某个时刻出现：左右指针指向</span></span><br><span class="line">        <span class="comment">// 的元素都是pivot，则两个while都不会执行，swap也不会产生什么效果，然后再进到新的</span></span><br><span class="line">        <span class="comment">// while(i &lt; j)的循环中时，也是如此。就一直卡这里了，所以会超时</span></span><br><span class="line">        <span class="comment">// 说到底，其实是因为我们的两个子循环的判断条件导致的：都是严格的小于/大于，而不是</span></span><br><span class="line">        <span class="comment">// 小于等于/大于等于</span></span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; pivot) i++;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i;</span></span><br><span class="line">        <span class="comment">// j--;</span></span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; pivot) j--;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; j;</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序">2.归并排序</h1>
<h2 id="核心思想分治思想-1">1.1.核心思想：分治思想</h2>
<h2 id="大致流程">1.2.大致流程：</h2>
<h3
id="这里也会选一个类似枢纽元的元素但是是固定选取为中间的那个元素我们的目标是把左半边和右半边的部分元素都排好序这样左右半边都是一个有序数组最后就可以用一个双指针法进行合并从而得到最终结果显然这里的关键在于如何快速高效地把左半边和右半边排好序以及如何合并结果下面是详细步骤">这里也会选一个类似枢纽元的元素，但是是固定选取为中间的那个元素。我们的目标是把左半边和右半边的部分元素都排好序，这样左右半边都是一个有序数组，最后就可以用一个双指针法进行合并，从而得到最终结果。显然，这里的关键在于如何快速高效地把左半边和右半边排好序，以及如何合并结果。下面是详细步骤</h3>
<h2 id="步骤-1">1.3.步骤：</h2>
<h3
id="先明确一下递归结束的条件若当前数组只有一个元素或没有元素则递归结束return否则还需继续进行递归那么就选择中间元素就是字面意思地进行选择">1.3.1.先明确一下递归结束的条件：若当前数组只有一个元素，或没有元素，则递归结束，return；否则还需继续进行递归，那么就选择中间元素，就是字面意思地进行选择</h3>
<h3
id="递归地对左右半边调用归并排序算法的函数这里回答了上面提到的如何快速高效地把左半边和右半边排好序理解上我们可以认为递归排序算法已经写好对左半边和右半边调用这个函数就可以实现排序">1.3.2.递归地对左右半边调用归并排序算法的函数（这里回答了上面提到的，如何快速高效地把左半边和右半边排好序）（理解上，我们可以认为，递归排序算法已经写好，对左半边和右半边调用这个函数就可以实现排序）</h3>
<h3
id="合并现在已经得到了左右半边两个有序的数组就要进行合并了原理上是很简单的-初始化两个指针分别指向左半边的开始和右半边的开始然后开始移动比较当前两个指针的元素指向元素较小的那个指针把它指向的那个元素存到一个中间数组里往中间数组里存储也是从左往右的并把指针往右移动一格如果遇到当前双指针指向的元素相同的情况那么我们一般是选择把左半边的那个指针的元素存到中间数组并移动左半边的那个指针因为这样可以保证归并排序是稳定的下面会细讲反正这个影响不大-如此一直重复直至有某个指针第一次到达了它的终点此时若另一个指针还没到终点则把它当前指向的元素及后面所有的元素都一并复制到中间数组里至此合并完成">1.3.3.合并。现在已经得到了左右半边两个有序的数组，就要进行合并了。原理上是很简单的。<br>初始化两个指针，分别指向左半边的开始和右半边的开始，然后开始移动。比较当前两个指针的元素，指向元素较小的那个指针，把它指向的那个元素存到一个中间数组里（往中间数组里存储，也是从左往右的），并把指针往右移动一格；如果遇到当前双指针指向的元素相同的情况，那么我们一般是选择把左半边的那个指针的元素存到中间数组，并移动左半边的那个指针（因为这样可以保证归并排序是稳定的。下面会细讲。反正这个影响不大）。<br>如此一直重复，直至有某个指针第一次到达了它的终点。此时若另一个指针还没到终点，则把它当前指向的元素及后面所有的元素都一并复制到中间数组里。至此，合并完成</h3>
<h2 id="代码模板">1.4.代码模板</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;    <span class="comment">// 这个 &gt;&gt; 操作相当于除以2并向下取整</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>
<h1 id="二分查找">3.二分查找</h1>
<h2
id="概述二分查找顾名思义是一种用来查找指定元素的算法它大致有两种一种是整数二分即在一个有序的整数序列中查找指定元素一种是浮点数二分或者说实数二分即在一个有序的实数区间里查找指定元素当然一般找到的可能是一个近似值比较麻烦的是整数二分因为它需要一些边界条件的判断而实数二分就比较简单了没有什么边界问题">3.0.概述：二分查找，顾名思义，是一种用来查找指定元素的算法。它大致有两种，一种是整数二分，即在一个有序的整数序列中查找指定元素；一种是浮点数二分，或者说实数二分，即在一个有序的实数区间里查找指定元素（当然一般找到的可能是一个近似值）。比较麻烦的是整数二分，因为它需要一些边界条件的判断。而实数二分就比较简单了，没有什么边界问题</h2>
<h2
id="核心思想需要澄清的一点是单调性是有利于二分查找的但并不意味着要用二分查找就一定要求输入满足单调性更抽象地说二分它分的依据是某个元素如果它满足一定性质则它的左边或它的右边一定会全都满足某种性质单调性是其中的一种特例譬如一个整数序列它是单调递增的我们想找元素x如果当前元素a它小于x根据单调性a右边的所有元素应该都大于等于a这就是我们说的它的左边或它的右边一定会全都满足某种性质因此x也应该在a的右边由此我们就缩小了查找x的范围了">3.1.核心思想：需要澄清的一点是，单调性是有利于二分查找的，但并不意味着要用二分查找就一定要求输入满足单调性。更抽象地说，二分，它“分”的依据是，某个元素，如果它满足一定性质，则它的左边或它的右边，一定会全都满足某种性质。单调性是其中的一种特例。譬如，一个整数序列，它是单调递增的。我们想找元素x，如果当前元素a它小于x，根据单调性，a右边的所有元素应该都大于等于a（这就是我们说的，它的左边或它的右边，一定会全都满足某种性质），因此x也应该在a的右边。由此我们就缩小了查找x的范围了</h2>
<h2 id="具体步骤">3.2.具体步骤：</h2>
<h3 id="整数二分">3.2.1.整数二分</h3>
<h4
id="比方说我们要在一个升序排列的数组里找到一个指定元素x通常的思路是先找到中间那个元素mid看看它是比x大还是小如果它比x大则x一定在左半边反之x在右半边在缩小的那半边里继续这一套流程直至区间里只有一个元素这就是我们查找的结果-上面的内容里有两点需要注意一个是中间元素mid怎么找看起来无关紧要但代码实现上的时候这里会影响到后面的代码实现且很容易出错第二点是查找结果我们的整数二分是一定会有一个结果的但本身这个待查找元素x未必就在数组里也就是说即使数组里没有这个元素我们用朴素的整数二分不做其它的处理还是会得到一个伪答案所以实际看题目如果题目说查找元素未必存在就需要多一些处理逻辑">比方说，我们要在一个升序排列的数组里找到一个指定元素x，通常的思路是先找到中间那个元素mid，看看它是比x大还是小：如果它比x大，则x一定在左半边；反之，x在右半边。在缩小的那半边里继续这一套流程，直至区间里只有一个元素，这就是我们查找的结果<br>上面的内容里有两点需要注意，一个是中间元素mid怎么找。看起来无关紧要，但代码实现上的时候，这里会影响到后面的代码实现，且很容易出错；第二点是“查找结果”，我们的整数二分是一定会有一个结果的，但本身这个待查找元素x未必就在数组里。也就是说，即使数组里没有这个元素，我们用朴素的整数二分，不做其它的处理，还是会得到一个“伪答案”。所以实际看题目，如果题目说查找元素未必存在，就需要多一些处理逻辑</h4>
<h4 id="代码模板-1">代码模板</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>
<h4
id="对上面的代码简单说明一下check函数其实是一种广义的函数它未必就是比大小需要看题目要求-然后上面是实现了两种二分查找可以看到两种方法的mid取法是不一样的且影响到后面区间的缩减实际我们应用的时候不需要死记硬背套这两个模板比较自然的思路是我们会依据题目条件先写好一个check并把区间缩减的方式写好之后我们可以再去更改mid的取法而之所以会有两种不同的取法主要是因为在第二种方法中有if-checkmid-l-mid这一行如果mid还是取为l-r-1则当l仅比r小1的时候如果checkmid成立了lmid而此时mid还是l就陷入了死循环了所以必须要加上一个1-故其实写代码的时候正如上面所说会先把if-else分支写好即分支缩减的方法因为这个是根据题意来的之后我们观察哪个边界会被幅值为mid如果是l-mid那么我们就要看如果mid-l-r-1那么当l和r仅相差1的时候这个mid就是l而如果发生了lmid的情况就相当于l和r都没变则会一直死循环所以mid应该更新为l-r-1-1类似的可以分析如果是r-mid则不需要加1mid-l-r-1即可">对上面的代码简单说明一下。check函数其实是一种广义的函数，它未必就是比大小，需要看题目要求<br>然后上面是实现了两种二分查找。可以看到，两种方法的mid取法是不一样的，且影响到后面区间的缩减。实际我们应用的时候，不需要死记硬背套这两个模板。比较自然的思路是，我们会依据题目条件，先写好一个check，并把区间缩减的方式写好。之后，我们可以再去更改mid的取法。而之所以会有两种不同的取法，主要是因为，在第二种方法中，有<code>if (check(mid)) l = mid;</code>这一行。如果mid还是取为l
+ r &gt;&gt;
1，则当l仅比r小1的时候，如果check(mid)成立了，l=mid，而此时mid还是l，就陷入了死循环了。所以必须要加上一个1<br>故，其实写代码的时候，正如上面所说，会先把if
else分支写好（即分支缩减的方法，因为这个是根据题意来的）；之后，我们观察哪个边界会被幅值为mid：如果是l
= mid，那么我们就要看，如果mid = l + r &gt;&gt;
1，那么，当l和r仅相差1的时候，这个mid就是l，而如果发生了l=mid的情况，就相当于l和r都没变，则会一直死循环，所以mid应该更新为l
+ r + 1 &gt;&gt; 1；类似的可以分析，如果是r = mid，则不需要加1，mid = l
+ r &gt;&gt; 1即可</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    <span class="keyword">while</span> (q--)     <span class="comment">//while(q--)的写法，刚好会循环q次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> query;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;query);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//下面这个for循环是用来找query出现的起始位置的</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; query) l = mid + <span class="number">1</span>;      <span class="comment">//因为是找起始位置，所以要注意用什么性质</span></span><br><span class="line">            <span class="comment">// 起始位置界满足的性质应该是，它左边的所有元素都严格小于query，所以这里if条件判断的</span></span><br><span class="line">            <span class="comment">// 时候用的是arr[mid] &lt; query</span></span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (arr[l] != query)    <span class="comment">// 此时跳出了第一个while，说明l == r，而如果arr[l] != query</span></span><br><span class="line">        <span class="comment">// 说明第一个大于等于query的元素，起始已经大于query了，所以这个数组里就没有这个query</span></span><br><span class="line">        <span class="comment">// 故按照题目说的来输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>        <span class="comment">//如果进入到了这个else分支，说明上面if不成立，也就是说，这个数组里确实是有</span></span><br><span class="line">        <span class="comment">// query元素的。则可以进一步的来判断query出现的终止位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;   <span class="comment">// 先输出一下上面已经求出的起始位置</span></span><br><span class="line">            r = n - <span class="number">1</span>;          <span class="comment">// 这里当然可以重新l = 0, r = n - 1；但，既然这里是求终止位置，</span></span><br><span class="line">            <span class="comment">// 终止位置肯定是大于等于起始位置，所以其实没必要把l重新初始化</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (arr[mid] &gt; query) r = mid - <span class="number">1</span>;  <span class="comment">// 这里因为是在找终止位置，而终止位置的性质</span></span><br><span class="line">                <span class="comment">// 是，它右边的元素一定严格大于query，故此处的条件是arr[mid] &gt; query</span></span><br><span class="line">                <span class="comment">// 而根据模板，当l = mid时，上面求mid的时候需要+1，以免出现死循环</span></span><br><span class="line">                <span class="keyword">else</span> l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浮点数二分">3.2.2.浮点数二分</h3>
<h4
id="这种情况我们一般要做的就是在一个区间里去逼近某个数这个数可能不能直接求出来例如求某个数的三次方根这个就简单多了不需要考虑什么边界情况只需要保证单调性即可还是以上面提到的三次方根为例开三次方的函数显然是单调递增的直接看代码就能懂了-还有个问题就是cpp中要用double类型不能float类型题目已经要求保留6位小数则间隔最大也要到1e-8级别了然而float能表示的有效数字大约是6-7位十进制数已经不太够了double能表示的有效数字大约是15-16位十进制数倒是够用输入n介于-10000和10000之间">这种情况，我们一般要做的就是在一个区间里，去逼近某个数，这个数可能不能直接求出来。例如，求某个数的三次方根。这个就简单多了，不需要考虑什么边界情况。只需要保证单调性即可。还是以上面提到的三次方根为例。开三次方的函数显然是单调递增的。直接看代码就能懂了<br>还有个问题，就是，cpp中，要用double类型，不能float类型。题目已经要求保留6位小数，则间隔最大也要到1e-8级别了。然而float能表示的有效数字大约是6-7位十进制数，已经不太够了；double能表示的有效数字大约是15-16位十进制数，倒是够用（输入n介于-10000和10000之间）</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">-10000</span>, r = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid * mid &lt; n) l = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mid * mid * mid &gt; n) r = mid;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">            cout &lt;&lt; mid;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">float</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 这里初始化的时候，如果不带.0，就默认l和r都是整数，于是后面while循环中计算mid的时候都是整数的除法，相当于</span></span><br><span class="line"><span class="comment"># (l + r) // 2    这会导致，后面当l和r只差1的时候，(l + r) // 2一直是l，所以l，r区间一直不变，且长度一直为</span></span><br><span class="line"><span class="comment"># 1，而我们跳出while循环的条件是区间长度小于等于1e-8，所以一直满足不了这个条件，死循环了，故TLE</span></span><br><span class="line"><span class="comment"># 带上.0以后，就默认l和r都是浮点数，后面的除2就是正常的除2，能得到精确的小数结果，所以没问题了</span></span><br><span class="line">l, r = -<span class="number">10000.0</span>, <span class="number">10000.0</span></span><br><span class="line"><span class="keyword">while</span> r - l &gt; <span class="number">1e-8</span>:</span><br><span class="line">    mid = (l + r) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> mid ** <span class="number">3</span> &gt; n:</span><br><span class="line">        r = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l = mid</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:.6f&#125;&quot;</span>.<span class="built_in">format</span>(l))</span><br></pre></td></tr></table></figure>
<h4
id="顺带说明一下python中的.formatf-string的用法.format是python的一种字符串格式化的一种语法也是比较老的一种先于f-string出现">顺带说明一下python中的.format/f-string的用法。.format是python的一种字符串格式化的一种语法（也是比较老的一种，先于f-string出现）</h4>
<h4
id="以上面用到的.6f为例是占位符是一个起始说明符它后面就是我们期望的格式而落回到这里.6f就是我们希望的格式.是精度指示符6代表要保留的小数位数所以这里.6f就代表我们期望的格式是保留6位小数">以上面用到的{:.6f}为例。{}是占位符，:是一个起始说明符，它后面就是我们期望的格式。而落回到这里，".6f"就是我们希望的格式，"."是精度指示符，"6"代表要保留的小数位数，所以这里".6f"就代表我们期望的格式是保留6位小数</h4>
<h4
id="至于f-string它是在python3.6之后才出现的也是用于控制字符串格式的它相比于.format特点就是更加简洁在此处如果我们还是希望输出保留6位小数用f-string则可以这样表示fl.6f这里我们直接把要输出的变量l放到里面至于和.6f的用法和功能则是和上面一样">至于f-string，它是在python3.6之后才出现的，也是用于控制字符串格式的。它相比于.format，特点就是更加简洁。在此处，如果我们还是希望输出保留6位小数，用f-string，则可以这样表示：f{l:.6f}。这里我们直接把要输出的变量l放到{}里面，至于":"和".6f"的用法和功能，则是和上面一样</h4>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/02/03/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/02/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap1.%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E9%AB%98%E7%B2%BE%E5%BA%A6&%E5%89%8D%E7%BC%80%E5%92%8C&%E5%B7%AE%E5%88%86/" rel="next" title="chap1.第二讲 高精度&前缀和&差分">
      chap1.第二讲 高精度&前缀和&差分 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">1.快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3"><span class="nav-number">1.1.</span> <span class="nav-text">1.1.核心思想：分治思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.2.</span> <span class="nav-text">1.2.步骤：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AA%E7%BB%99%E5%AE%9A%E7%9A%84%E6%95%B0%E7%BB%84%E9%80%89%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%B8%AD%E9%97%B4%E5%80%BCx%E7%90%86%E8%AE%BA%E4%B8%8A%E6%9D%A5%E8%AF%B4%E9%80%89%E5%93%AA%E4%B8%AA%E9%83%BD%E8%A1%8C%E4%BD%86%E5%90%8E%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9B%B8%E5%BA%94%E7%9A%84%E6%90%AD%E9%85%8D%E5%90%A6%E5%88%99%E4%BC%9A%E9%99%B7%E5%85%A5%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%90%8E%E9%9D%A2%E5%85%B7%E4%BD%93%E8%AE%B2%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%B1%E6%98%AF%E9%80%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B7%A6%E8%BE%B9%E5%8F%B3%E8%BE%B9%E4%B8%AD%E9%97%B4%E5%80%BC%E9%9A%8F%E6%9C%BA%E9%80%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1.对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边&#x2F;右边&#x2F;中间值&#x2F;随机选</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E5%8C%BA%E9%97%B4%E8%BF%99%E4%B8%80%E6%AD%A5%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E4%BD%BF%E5%BE%97%E6%95%B0%E7%BB%84%E7%9A%84%E5%B7%A6%E8%BE%B9%E9%83%A8%E5%88%86%E7%9A%84%E5%85%83%E7%B4%A0%E5%85%A8%E9%83%BD%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%B8%AD%E9%97%B4%E5%80%BCx%E5%8F%B3%E8%BE%B9%E9%83%A8%E5%88%86%E7%9A%84%E5%85%83%E7%B4%A0%E5%85%A8%E9%83%BD%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E6%AD%A4%E6%97%B6%E4%B8%80%E5%AE%9A%E6%9C%89%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%85%83%E7%B4%A0%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%85%83%E7%B4%A0%E8%BF%99%E6%98%AF%E5%BF%AB%E6%8E%92%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2.调整区间：这一步的目的是，调整数组，使得数组的左边部分的元素全都小于等于中间值x，右边部分的元素全都大于等于x（此时，一定有右边的元素大于等于左边的元素。这是快排正确性的保证）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AF%B9%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%B7%A6%E8%BE%B9%E5%92%8C%E5%8F%B3%E8%BE%B9%E9%83%A8%E5%88%86%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%9F%E8%BF%9B%E8%A1%8C1.2.1-1.2.2%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3.递归：对上面的左边和右边部分的子数组也进行1.2.1-1.2.2的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4%E5%BA%94%E8%AF%A5%E6%98%AF1.2.2%E8%80%8C%E5%85%B3%E4%BA%8E1.2.2%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%86%8D%E5%BC%80%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84ab%E7%84%B6%E5%90%8E%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E6%89%AB%E6%8F%8F%E4%B8%80%E9%81%8D%E5%BE%85%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84s%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%B8%AD%E9%97%B4%E5%80%BC%E5%88%99%E6%94%BE%E5%88%B0%E6%95%B0%E7%BB%84a%E9%87%8C%E5%A4%A7%E4%BA%8E%E4%B8%AD%E9%97%B4%E5%80%BC%E5%88%99%E6%94%BE%E5%88%B0b%E9%87%8C%E6%89%AB%E6%8F%8F%E5%AE%8C%E4%B9%8B%E5%90%8E%E5%85%88%E6%8A%8Aa%E7%9A%84%E5%85%83%E7%B4%A0%E6%94%BE%E5%9B%9Es%E9%87%8C%E5%86%8D%E6%8A%8Ab%E7%9A%84%E5%85%83%E7%B4%A0%E6%94%BE%E5%9B%9Es%E9%87%8C%E6%94%BE%E5%9B%9E%E5%8E%BB%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B9%9F%E4%BB%8E%E5%B7%A6%E5%BE%80%E5%8F%B3%E5%8D%B3%E5%8F%AF%E5%B0%B1%E5%AE%8C%E6%88%90%E4%BA%86%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8A%E5%9B%A0%E4%B8%BA%E8%A6%81%E6%89%AB%E6%8F%8F%E4%B8%80%E9%81%8D%E6%94%BE%E5%9B%9E%E4%B8%80%E9%81%8D%E5%BA%94%E8%AF%A5%E6%98%AF2n%E4%B9%9F%E5%B0%B1%E6%98%AFon%E4%B8%BB%E8%A6%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%9C%A8%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8A%E9%9C%80%E8%A6%81%E5%86%8D%E5%BC%80%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%8D%E5%A4%AA%E5%A5%BD"><span class="nav-number">1.2.4.</span> <span class="nav-text">可以看到，核心步骤应该是1.2.2。而关于1.2.2的实现，一个比较简单粗暴的方法是，再开两个数组a，b，然后，从左到右扫描一遍待排序的数组s，如果一个元素小于等于中间值，则放到数组a里，大于中间值，则放到b里。扫描完之后，先把a的元素放回s里，再把b的元素放回s里（放回去的顺序也从左往右即可），就完成了。时间复杂度上，因为要扫描一遍，放回一遍，应该是2N，也就是\(O(N)\)；主要的问题在空间复杂度上，需要再开两个数组，不太好</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%8C%E6%88%91%E4%B8%AA%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E6%83%B3%E6%B3%95%E6%98%AF%E6%9C%AC%E8%B4%A8%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="nav-number">1.2.5.</span> <span class="nav-text">而我个人的第一想法是，（本质也是一个双指针法）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99%E4%B8%80%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88%E8%B5%B7%E5%A7%8B%E5%88%86%E5%88%AB%E5%9C%A8s%E7%9A%84%E6%9C%80%E5%B7%A6%E8%BE%B9%E5%92%8C%E6%9C%80%E5%8F%B3%E8%BE%B9"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">给一组双指针，起始分别在s的最左边和最右边。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E6%8C%87%E9%92%88%E4%BB%8E%E5%B7%A6%E5%BE%80%E5%8F%B3%E7%A7%BB%E5%8A%A8%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E5%B7%A6%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%85%83%E7%B4%A0%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%B8%AD%E9%97%B4%E5%80%BCx%E5%88%99%E4%B8%8D%E5%8A%A8%E5%AE%83%E7%BB%A7%E7%BB%AD%E5%BE%80%E5%8F%B3%E8%B5%B0%E4%B8%80%E6%A0%BC%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E5%B7%A6%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%85%83%E7%B4%A0%E5%A4%A7%E4%BA%8E%E4%B8%AD%E9%97%B4%E5%80%BCx%E5%88%99%E6%8A%8A%E5%AE%83%E5%92%8Cs%E7%9A%84%E5%8F%B3%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E5%90%8C%E6%97%B6%E5%8F%B3%E6%8C%87%E9%92%88%E5%BE%80%E5%B7%A6%E8%B5%B0%E4%B8%80%E6%A0%BC%E5%B7%A6%E6%8C%87%E9%92%88%E5%85%88%E4%B8%8D%E5%8A%A8%E6%8D%A2%E8%BF%87%E6%9D%A5%E7%9A%84%E6%96%B0%E5%85%83%E7%B4%A0%E5%A6%82%E6%9E%9C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E5%88%99%E5%B7%A6%E6%8C%87%E9%92%88%E5%BE%80%E5%8F%B3%E8%B5%B0%E4%B8%80%E6%A0%BC%E5%A6%82%E6%9E%9C%E6%8D%A2%E8%BF%87%E6%9D%A5%E7%9A%84%E6%96%B0%E5%85%83%E7%B4%A0%E8%BF%98%E6%98%AF%E5%A4%A7%E4%BA%8Ex%E5%88%99%E5%86%8D%E8%AE%A9%E5%AE%83%E5%92%8C%E5%8F%B3%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%85%83%E7%B4%A0%E4%BA%A4%E6%8D%A2%E4%B8%80%E4%B8%8B%E6%B3%A8%E6%84%8F%E4%B8%8A%E9%9D%A2%E5%B7%B2%E7%BB%8F%E8%AE%A9%E5%8F%B3%E6%8C%87%E9%92%88%E5%BE%80%E5%B7%A6%E8%B5%B0%E4%B8%80%E6%A0%BC%E4%BA%86"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">左指针从左往右移动，如果当前左指针指向的元素小于等于中间值x，则不动它，继续往右走一格；如果当前左指针指向的元素大于中间值x，则把它和s的右指针指向的元素替换，同时右指针往左走一格，左指针先不动：换过来的新元素如果小于等于x，则左指针往右走一格；如果换过来的新元素还是大于x，则再让它和右指针指向的元素交换一下（注意，上面已经让右指针往左走一格了），</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%84%B6%E5%90%8E%E4%B8%80%E7%9B%B4%E9%87%8D%E5%A4%8D%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%88%A4%E6%96%AD%E7%9B%B4%E5%88%B0%E5%B7%A6%E6%8C%87%E9%92%88%E7%BB%A7%E7%BB%AD%E5%BE%80%E5%8F%B3%E8%B5%B0%E4%BA%86%E6%88%96%E8%80%85%E6%98%AF%E5%8F%B3%E6%8C%87%E9%92%88%E4%B8%80%E7%9B%B4%E5%BE%80%E5%B7%A6%E8%B5%B0%E8%B5%B0%E5%88%B0%E4%BA%86%E4%B8%8E%E5%B7%A6%E6%8C%87%E9%92%88%E7%9B%B8%E9%81%87%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%84%9F%E8%A7%89%E5%85%B6%E5%AE%9E%E5%B7%B2%E7%BB%8F%E5%BE%88%E6%8E%A5%E8%BF%91%E7%BB%99%E7%9A%84%E6%A8%A1%E6%9D%BF%E4%BA%86"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">然后一直重复上面的判断，直到左指针继续往右走了，或者是右指针一直往左走，走到了与左指针相遇的位置（感觉其实已经很接近给的模板了）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%AF%9D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8F%8C%E6%8C%87%E9%92%88%E6%AF%94%E6%88%91%E7%9A%84%E7%A8%8D%E5%BE%AE%E7%AE%80%E6%B4%81%E4%B8%80%E7%82%B9%E4%B8%BB%E8%A6%81%E7%9A%84%E6%94%B9%E8%BF%9B%E5%9C%A8%E4%BA%8E%E6%88%91%E7%9A%84%E6%96%B9%E6%B3%95%E5%9C%A8%E9%81%87%E5%88%B0%E5%B7%A6%E6%8C%87%E9%92%88%E5%85%83%E7%B4%A0%E5%A4%A7%E4%BA%8Ex%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%92%8C%E5%8F%B3%E6%8C%87%E9%92%88%E5%85%83%E7%B4%A0%E4%BA%A4%E6%8D%A2%E4%B8%94%E5%8F%B3%E6%8C%87%E9%92%88%E4%B8%80%E5%AE%9A%E5%BE%80%E8%B5%B0%E4%B8%80%E6%A0%BC%E8%80%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF"><span class="nav-number">1.2.6.</span> <span class="nav-text">模板的话，是一个双指针，比我的稍微简洁一点。主要的改进在于，我的方法在遇到左指针元素大于x的时候，一定会和右指针元素交换，且右指针一定往走一格；而模板的方法是，</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%A6%E6%8C%87%E9%92%88%E5%85%83%E7%B4%A0%E5%B0%8F%E4%BA%8Ex%E5%88%99%E7%AC%A6%E5%90%88%E8%A6%81%E6%B1%82%E5%B7%A6%E6%8C%87%E9%92%88%E5%BE%80%E5%8F%B3%E8%B5%B0%E4%B8%80%E6%A0%BC%E5%A6%82%E6%9E%9C%E5%B7%A6%E6%8C%87%E9%92%88%E5%85%83%E7%B4%A0%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E5%88%99%E6%88%91%E4%B8%8D%E5%8A%A8%E5%B7%A6%E6%8C%87%E9%92%88%E4%BA%86%E5%8E%BB%E7%A7%BB%E5%8A%A8%E5%8F%B3%E6%8C%87%E9%92%88%E5%A6%82%E6%9E%9C%E5%8F%B3%E6%8C%87%E9%92%88%E5%85%83%E7%B4%A0%E5%A4%A7%E4%BA%8Ex%E4%B9%9F%E7%AC%A6%E5%90%88%E8%A6%81%E6%B1%82%E5%88%99%E5%8F%B3%E6%8C%87%E9%92%88%E5%BE%80%E5%B7%A6%E8%B5%B0%E4%B8%80%E6%A0%BC%E5%A6%82%E6%9E%9C%E5%8F%B3%E6%8C%87%E9%92%88%E5%85%83%E7%B4%A0%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E5%88%99%E7%8E%B0%E5%9C%A8%E7%9A%84%E6%83%85%E5%86%B5%E6%98%AF%E5%B7%A6%E6%8C%87%E9%92%88%E5%85%83%E7%B4%A0%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E5%8F%B3%E6%8C%87%E9%92%88%E5%85%83%E7%B4%A0%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ex%E5%AE%83%E4%BB%AC%E4%BA%A4%E6%8D%A2%E4%B8%80%E4%B8%8B%E5%B0%B1%E5%88%9A%E5%A5%BD%E7%AC%A6%E5%90%88%E8%A6%81%E6%B1%82%E4%BA%86%E6%95%85%E4%BA%A4%E6%8D%A2%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%85%83%E7%B4%A0%E4%B9%8B%E5%90%8E%E7%BB%A7%E7%BB%AD%E7%A7%BB%E5%8A%A8%E5%B7%A6%E6%8C%87%E9%92%88%E9%87%8D%E5%A4%8D%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E7%9B%B4%E8%87%B3%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88%E7%9B%B8%E9%81%87%E6%88%96%E8%80%85%E5%8F%B3%E6%8C%87%E9%92%88%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B5%B0%E5%88%B0%E5%B7%A6%E6%8C%87%E9%92%88%E5%B7%A6%E8%BE%B9%E5%B7%A6%E6%8C%87%E9%92%88%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B5%B0%E5%88%B0%E5%8F%B3%E6%8C%87%E9%92%88%E5%8F%B3%E8%BE%B9%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E5%A6%82%E4%B8%8B"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">如果左指针元素小于x，则符合要求，左指针往右走一格；如果左指针元素大于等于x，则我不动左指针了，去移动右指针：如果右指针元素大于x，也符合要求，则右指针往左走一格；如果右指针元素小于等于x，则现在的情况是：左指针元素大于等于x，右指针元素小于等于x，它们交换一下就刚好符合要求了，故交换左右指针指向的元素。之后继续移动左指针，重复上面的步骤，直至左右指针相遇（或者右指针第一次走到左指针左边&#x2F;左指针第一次走到右指针右边）。代码模板如下：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF%E5%8F%98%E5%8C%96%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E5%B0%B1%E6%98%AF%E8%AF%B4%E5%A6%82%E6%9E%9C%E5%90%8E%E9%9D%A2%E9%80%92%E5%BD%92%E7%9A%84%E6%97%B6%E5%80%99%E7%94%A8i%E6%9D%A5%E5%88%92%E5%88%86%E8%BE%B9%E7%95%8Cquick_sortq-l-i---1-quick_sortq-i-r%E5%88%99%E4%B8%8A%E9%9D%A2%E9%80%89%E6%9E%A2%E7%BA%BD%E5%85%83%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E8%83%BD%E9%80%89ql%E7%B1%BB%E4%BC%BC%E7%9A%84%E7%94%A8j%E6%9D%A5%E5%88%92%E5%88%86%E8%BE%B9%E7%95%8C%E7%9A%84%E6%97%B6%E5%80%99%E6%9E%A2%E7%BA%BD%E5%85%83%E5%B0%B1%E4%B8%8D%E8%83%BD%E5%8F%96qr%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.</span> <span class="nav-text">问题：模板变化的原理是？就是说，如果后面递归的时候，用i来划分边界，quick_sort(q,
l, i - 1), quick_sort(q, i,
r)，则上面选枢纽元的时候不能选q[l]？类似的，用j来划分边界的时候，枢纽元就不能取q[r]？为什么？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">2.归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3-1"><span class="nav-number">2.1.</span> <span class="nav-text">1.1.核心思想：分治思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">1.2.大致流程：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%99%E9%87%8C%E4%B9%9F%E4%BC%9A%E9%80%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%E6%9E%A2%E7%BA%BD%E5%85%83%E7%9A%84%E5%85%83%E7%B4%A0%E4%BD%86%E6%98%AF%E6%98%AF%E5%9B%BA%E5%AE%9A%E9%80%89%E5%8F%96%E4%B8%BA%E4%B8%AD%E9%97%B4%E7%9A%84%E9%82%A3%E4%B8%AA%E5%85%83%E7%B4%A0%E6%88%91%E4%BB%AC%E7%9A%84%E7%9B%AE%E6%A0%87%E6%98%AF%E6%8A%8A%E5%B7%A6%E5%8D%8A%E8%BE%B9%E5%92%8C%E5%8F%B3%E5%8D%8A%E8%BE%B9%E7%9A%84%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0%E9%83%BD%E6%8E%92%E5%A5%BD%E5%BA%8F%E8%BF%99%E6%A0%B7%E5%B7%A6%E5%8F%B3%E5%8D%8A%E8%BE%B9%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%9C%80%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6%E4%BB%8E%E8%80%8C%E5%BE%97%E5%88%B0%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C%E6%98%BE%E7%84%B6%E8%BF%99%E9%87%8C%E7%9A%84%E5%85%B3%E9%94%AE%E5%9C%A8%E4%BA%8E%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%AB%98%E6%95%88%E5%9C%B0%E6%8A%8A%E5%B7%A6%E5%8D%8A%E8%BE%B9%E5%92%8C%E5%8F%B3%E5%8D%8A%E8%BE%B9%E6%8E%92%E5%A5%BD%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E7%BB%93%E6%9E%9C%E4%B8%8B%E9%9D%A2%E6%98%AF%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.2.1.</span> <span class="nav-text">这里也会选一个类似枢纽元的元素，但是是固定选取为中间的那个元素。我们的目标是把左半边和右半边的部分元素都排好序，这样左右半边都是一个有序数组，最后就可以用一个双指针法进行合并，从而得到最终结果。显然，这里的关键在于如何快速高效地把左半边和右半边排好序，以及如何合并结果。下面是详细步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">2.3.</span> <span class="nav-text">1.3.步骤：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%98%8E%E7%A1%AE%E4%B8%80%E4%B8%8B%E9%80%92%E5%BD%92%E7%BB%93%E6%9D%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%8B%A5%E5%BD%93%E5%89%8D%E6%95%B0%E7%BB%84%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%88%96%E6%B2%A1%E6%9C%89%E5%85%83%E7%B4%A0%E5%88%99%E9%80%92%E5%BD%92%E7%BB%93%E6%9D%9Freturn%E5%90%A6%E5%88%99%E8%BF%98%E9%9C%80%E7%BB%A7%E7%BB%AD%E8%BF%9B%E8%A1%8C%E9%80%92%E5%BD%92%E9%82%A3%E4%B9%88%E5%B0%B1%E9%80%89%E6%8B%A9%E4%B8%AD%E9%97%B4%E5%85%83%E7%B4%A0%E5%B0%B1%E6%98%AF%E5%AD%97%E9%9D%A2%E6%84%8F%E6%80%9D%E5%9C%B0%E8%BF%9B%E8%A1%8C%E9%80%89%E6%8B%A9"><span class="nav-number">2.3.1.</span> <span class="nav-text">1.3.1.先明确一下递归结束的条件：若当前数组只有一个元素，或没有元素，则递归结束，return；否则还需继续进行递归，那么就选择中间元素，就是字面意思地进行选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%9C%B0%E5%AF%B9%E5%B7%A6%E5%8F%B3%E5%8D%8A%E8%BE%B9%E8%B0%83%E7%94%A8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%BD%E6%95%B0%E8%BF%99%E9%87%8C%E5%9B%9E%E7%AD%94%E4%BA%86%E4%B8%8A%E9%9D%A2%E6%8F%90%E5%88%B0%E7%9A%84%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%AB%98%E6%95%88%E5%9C%B0%E6%8A%8A%E5%B7%A6%E5%8D%8A%E8%BE%B9%E5%92%8C%E5%8F%B3%E5%8D%8A%E8%BE%B9%E6%8E%92%E5%A5%BD%E5%BA%8F%E7%90%86%E8%A7%A3%E4%B8%8A%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%AE%A4%E4%B8%BA%E9%80%92%E5%BD%92%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%B7%B2%E7%BB%8F%E5%86%99%E5%A5%BD%E5%AF%B9%E5%B7%A6%E5%8D%8A%E8%BE%B9%E5%92%8C%E5%8F%B3%E5%8D%8A%E8%BE%B9%E8%B0%83%E7%94%A8%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">2.3.2.</span> <span class="nav-text">1.3.2.递归地对左右半边调用归并排序算法的函数（这里回答了上面提到的，如何快速高效地把左半边和右半边排好序）（理解上，我们可以认为，递归排序算法已经写好，对左半边和右半边调用这个函数就可以实现排序）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E7%8E%B0%E5%9C%A8%E5%B7%B2%E7%BB%8F%E5%BE%97%E5%88%B0%E4%BA%86%E5%B7%A6%E5%8F%B3%E5%8D%8A%E8%BE%B9%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E5%B0%B1%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6%E4%BA%86%E5%8E%9F%E7%90%86%E4%B8%8A%E6%98%AF%E5%BE%88%E7%AE%80%E5%8D%95%E7%9A%84-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E5%88%86%E5%88%AB%E6%8C%87%E5%90%91%E5%B7%A6%E5%8D%8A%E8%BE%B9%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E5%8F%B3%E5%8D%8A%E8%BE%B9%E7%9A%84%E5%BC%80%E5%A7%8B%E7%84%B6%E5%90%8E%E5%BC%80%E5%A7%8B%E7%A7%BB%E5%8A%A8%E6%AF%94%E8%BE%83%E5%BD%93%E5%89%8D%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E7%9A%84%E5%85%83%E7%B4%A0%E6%8C%87%E5%90%91%E5%85%83%E7%B4%A0%E8%BE%83%E5%B0%8F%E7%9A%84%E9%82%A3%E4%B8%AA%E6%8C%87%E9%92%88%E6%8A%8A%E5%AE%83%E6%8C%87%E5%90%91%E7%9A%84%E9%82%A3%E4%B8%AA%E5%85%83%E7%B4%A0%E5%AD%98%E5%88%B0%E4%B8%80%E4%B8%AA%E4%B8%AD%E9%97%B4%E6%95%B0%E7%BB%84%E9%87%8C%E5%BE%80%E4%B8%AD%E9%97%B4%E6%95%B0%E7%BB%84%E9%87%8C%E5%AD%98%E5%82%A8%E4%B9%9F%E6%98%AF%E4%BB%8E%E5%B7%A6%E5%BE%80%E5%8F%B3%E7%9A%84%E5%B9%B6%E6%8A%8A%E6%8C%87%E9%92%88%E5%BE%80%E5%8F%B3%E7%A7%BB%E5%8A%A8%E4%B8%80%E6%A0%BC%E5%A6%82%E6%9E%9C%E9%81%87%E5%88%B0%E5%BD%93%E5%89%8D%E5%8F%8C%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%85%83%E7%B4%A0%E7%9B%B8%E5%90%8C%E7%9A%84%E6%83%85%E5%86%B5%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%80%E8%88%AC%E6%98%AF%E9%80%89%E6%8B%A9%E6%8A%8A%E5%B7%A6%E5%8D%8A%E8%BE%B9%E7%9A%84%E9%82%A3%E4%B8%AA%E6%8C%87%E9%92%88%E7%9A%84%E5%85%83%E7%B4%A0%E5%AD%98%E5%88%B0%E4%B8%AD%E9%97%B4%E6%95%B0%E7%BB%84%E5%B9%B6%E7%A7%BB%E5%8A%A8%E5%B7%A6%E5%8D%8A%E8%BE%B9%E7%9A%84%E9%82%A3%E4%B8%AA%E6%8C%87%E9%92%88%E5%9B%A0%E4%B8%BA%E8%BF%99%E6%A0%B7%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%98%AF%E7%A8%B3%E5%AE%9A%E7%9A%84%E4%B8%8B%E9%9D%A2%E4%BC%9A%E7%BB%86%E8%AE%B2%E5%8F%8D%E6%AD%A3%E8%BF%99%E4%B8%AA%E5%BD%B1%E5%93%8D%E4%B8%8D%E5%A4%A7-%E5%A6%82%E6%AD%A4%E4%B8%80%E7%9B%B4%E9%87%8D%E5%A4%8D%E7%9B%B4%E8%87%B3%E6%9C%89%E6%9F%90%E4%B8%AA%E6%8C%87%E9%92%88%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%B0%E8%BE%BE%E4%BA%86%E5%AE%83%E7%9A%84%E7%BB%88%E7%82%B9%E6%AD%A4%E6%97%B6%E8%8B%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E8%BF%98%E6%B2%A1%E5%88%B0%E7%BB%88%E7%82%B9%E5%88%99%E6%8A%8A%E5%AE%83%E5%BD%93%E5%89%8D%E6%8C%87%E5%90%91%E7%9A%84%E5%85%83%E7%B4%A0%E5%8F%8A%E5%90%8E%E9%9D%A2%E6%89%80%E6%9C%89%E7%9A%84%E5%85%83%E7%B4%A0%E9%83%BD%E4%B8%80%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0%E4%B8%AD%E9%97%B4%E6%95%B0%E7%BB%84%E9%87%8C%E8%87%B3%E6%AD%A4%E5%90%88%E5%B9%B6%E5%AE%8C%E6%88%90"><span class="nav-number">2.3.3.</span> <span class="nav-text">1.3.3.合并。现在已经得到了左右半边两个有序的数组，就要进行合并了。原理上是很简单的。初始化两个指针，分别指向左半边的开始和右半边的开始，然后开始移动。比较当前两个指针的元素，指向元素较小的那个指针，把它指向的那个元素存到一个中间数组里（往中间数组里存储，也是从左往右的），并把指针往右移动一格；如果遇到当前双指针指向的元素相同的情况，那么我们一般是选择把左半边的那个指针的元素存到中间数组，并移动左半边的那个指针（因为这样可以保证归并排序是稳定的。下面会细讲。反正这个影响不大）。如此一直重复，直至有某个指针第一次到达了它的终点。此时若另一个指针还没到终点，则把它当前指向的元素及后面所有的元素都一并复制到中间数组里。至此，合并完成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.4.</span> <span class="nav-text">1.4.代码模板</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">3.</span> <span class="nav-text">3.二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%A1%BE%E5%90%8D%E6%80%9D%E4%B9%89%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%A8%E6%9D%A5%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%83%E5%A4%A7%E8%87%B4%E6%9C%89%E4%B8%A4%E7%A7%8D%E4%B8%80%E7%A7%8D%E6%98%AF%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E5%8D%B3%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E4%B8%80%E7%A7%8D%E6%98%AF%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86%E6%88%96%E8%80%85%E8%AF%B4%E5%AE%9E%E6%95%B0%E4%BA%8C%E5%88%86%E5%8D%B3%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E5%AE%9E%E6%95%B0%E5%8C%BA%E9%97%B4%E9%87%8C%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E5%BD%93%E7%84%B6%E4%B8%80%E8%88%AC%E6%89%BE%E5%88%B0%E7%9A%84%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E8%BF%91%E4%BC%BC%E5%80%BC%E6%AF%94%E8%BE%83%E9%BA%BB%E7%83%A6%E7%9A%84%E6%98%AF%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E5%9B%A0%E4%B8%BA%E5%AE%83%E9%9C%80%E8%A6%81%E4%B8%80%E4%BA%9B%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%88%A4%E6%96%AD%E8%80%8C%E5%AE%9E%E6%95%B0%E4%BA%8C%E5%88%86%E5%B0%B1%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%E4%BA%86%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.</span> <span class="nav-text">3.0.概述：二分查找，顾名思义，是一种用来查找指定元素的算法。它大致有两种，一种是整数二分，即在一个有序的整数序列中查找指定元素；一种是浮点数二分，或者说实数二分，即在一个有序的实数区间里查找指定元素（当然一般找到的可能是一个近似值）。比较麻烦的是整数二分，因为它需要一些边界条件的判断。而实数二分就比较简单了，没有什么边界问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E9%9C%80%E8%A6%81%E6%BE%84%E6%B8%85%E7%9A%84%E4%B8%80%E7%82%B9%E6%98%AF%E5%8D%95%E8%B0%83%E6%80%A7%E6%98%AF%E6%9C%89%E5%88%A9%E4%BA%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E4%BD%86%E5%B9%B6%E4%B8%8D%E6%84%8F%E5%91%B3%E7%9D%80%E8%A6%81%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E6%B1%82%E8%BE%93%E5%85%A5%E6%BB%A1%E8%B6%B3%E5%8D%95%E8%B0%83%E6%80%A7%E6%9B%B4%E6%8A%BD%E8%B1%A1%E5%9C%B0%E8%AF%B4%E4%BA%8C%E5%88%86%E5%AE%83%E5%88%86%E7%9A%84%E4%BE%9D%E6%8D%AE%E6%98%AF%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E5%A6%82%E6%9E%9C%E5%AE%83%E6%BB%A1%E8%B6%B3%E4%B8%80%E5%AE%9A%E6%80%A7%E8%B4%A8%E5%88%99%E5%AE%83%E7%9A%84%E5%B7%A6%E8%BE%B9%E6%88%96%E5%AE%83%E7%9A%84%E5%8F%B3%E8%BE%B9%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%85%A8%E9%83%BD%E6%BB%A1%E8%B6%B3%E6%9F%90%E7%A7%8D%E6%80%A7%E8%B4%A8%E5%8D%95%E8%B0%83%E6%80%A7%E6%98%AF%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E7%A7%8D%E7%89%B9%E4%BE%8B%E8%AD%AC%E5%A6%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E5%AE%83%E6%98%AF%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%88%91%E4%BB%AC%E6%83%B3%E6%89%BE%E5%85%83%E7%B4%A0x%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0a%E5%AE%83%E5%B0%8F%E4%BA%8Ex%E6%A0%B9%E6%8D%AE%E5%8D%95%E8%B0%83%E6%80%A7a%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%BA%94%E8%AF%A5%E9%83%BD%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Ea%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E8%AF%B4%E7%9A%84%E5%AE%83%E7%9A%84%E5%B7%A6%E8%BE%B9%E6%88%96%E5%AE%83%E7%9A%84%E5%8F%B3%E8%BE%B9%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%85%A8%E9%83%BD%E6%BB%A1%E8%B6%B3%E6%9F%90%E7%A7%8D%E6%80%A7%E8%B4%A8%E5%9B%A0%E6%AD%A4x%E4%B9%9F%E5%BA%94%E8%AF%A5%E5%9C%A8a%E7%9A%84%E5%8F%B3%E8%BE%B9%E7%94%B1%E6%AD%A4%E6%88%91%E4%BB%AC%E5%B0%B1%E7%BC%A9%E5%B0%8F%E4%BA%86%E6%9F%A5%E6%89%BEx%E7%9A%84%E8%8C%83%E5%9B%B4%E4%BA%86"><span class="nav-number">3.2.</span> <span class="nav-text">3.1.核心思想：需要澄清的一点是，单调性是有利于二分查找的，但并不意味着要用二分查找就一定要求输入满足单调性。更抽象地说，二分，它“分”的依据是，某个元素，如果它满足一定性质，则它的左边或它的右边，一定会全都满足某种性质。单调性是其中的一种特例。譬如，一个整数序列，它是单调递增的。我们想找元素x，如果当前元素a它小于x，根据单调性，a右边的所有元素应该都大于等于a（这就是我们说的，它的左边或它的右边，一定会全都满足某种性质），因此x也应该在a的右边。由此我们就缩小了查找x的范围了</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.3.</span> <span class="nav-text">3.2.具体步骤：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.2.1.整数二分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E6%96%B9%E8%AF%B4%E6%88%91%E4%BB%AC%E8%A6%81%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%8D%87%E5%BA%8F%E6%8E%92%E5%88%97%E7%9A%84%E6%95%B0%E7%BB%84%E9%87%8C%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0x%E9%80%9A%E5%B8%B8%E7%9A%84%E6%80%9D%E8%B7%AF%E6%98%AF%E5%85%88%E6%89%BE%E5%88%B0%E4%B8%AD%E9%97%B4%E9%82%A3%E4%B8%AA%E5%85%83%E7%B4%A0mid%E7%9C%8B%E7%9C%8B%E5%AE%83%E6%98%AF%E6%AF%94x%E5%A4%A7%E8%BF%98%E6%98%AF%E5%B0%8F%E5%A6%82%E6%9E%9C%E5%AE%83%E6%AF%94x%E5%A4%A7%E5%88%99x%E4%B8%80%E5%AE%9A%E5%9C%A8%E5%B7%A6%E5%8D%8A%E8%BE%B9%E5%8F%8D%E4%B9%8Bx%E5%9C%A8%E5%8F%B3%E5%8D%8A%E8%BE%B9%E5%9C%A8%E7%BC%A9%E5%B0%8F%E7%9A%84%E9%82%A3%E5%8D%8A%E8%BE%B9%E9%87%8C%E7%BB%A7%E7%BB%AD%E8%BF%99%E4%B8%80%E5%A5%97%E6%B5%81%E7%A8%8B%E7%9B%B4%E8%87%B3%E5%8C%BA%E9%97%B4%E9%87%8C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E6%9F%A5%E6%89%BE%E7%9A%84%E7%BB%93%E6%9E%9C-%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E9%87%8C%E6%9C%89%E4%B8%A4%E7%82%B9%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%80%E4%B8%AA%E6%98%AF%E4%B8%AD%E9%97%B4%E5%85%83%E7%B4%A0mid%E6%80%8E%E4%B9%88%E6%89%BE%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%97%A0%E5%85%B3%E7%B4%A7%E8%A6%81%E4%BD%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%99%E9%87%8C%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%88%B0%E5%90%8E%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%94%E5%BE%88%E5%AE%B9%E6%98%93%E5%87%BA%E9%94%99%E7%AC%AC%E4%BA%8C%E7%82%B9%E6%98%AF%E6%9F%A5%E6%89%BE%E7%BB%93%E6%9E%9C%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E6%98%AF%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%9C%89%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%9C%E7%9A%84%E4%BD%86%E6%9C%AC%E8%BA%AB%E8%BF%99%E4%B8%AA%E5%BE%85%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0x%E6%9C%AA%E5%BF%85%E5%B0%B1%E5%9C%A8%E6%95%B0%E7%BB%84%E9%87%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E5%8D%B3%E4%BD%BF%E6%95%B0%E7%BB%84%E9%87%8C%E6%B2%A1%E6%9C%89%E8%BF%99%E4%B8%AA%E5%85%83%E7%B4%A0%E6%88%91%E4%BB%AC%E7%94%A8%E6%9C%B4%E7%B4%A0%E7%9A%84%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E4%B8%8D%E5%81%9A%E5%85%B6%E5%AE%83%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%98%E6%98%AF%E4%BC%9A%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E4%BC%AA%E7%AD%94%E6%A1%88%E6%89%80%E4%BB%A5%E5%AE%9E%E9%99%85%E7%9C%8B%E9%A2%98%E7%9B%AE%E5%A6%82%E6%9E%9C%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E6%9C%AA%E5%BF%85%E5%AD%98%E5%9C%A8%E5%B0%B1%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B8%80%E4%BA%9B%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">比方说，我们要在一个升序排列的数组里找到一个指定元素x，通常的思路是先找到中间那个元素mid，看看它是比x大还是小：如果它比x大，则x一定在左半边；反之，x在右半边。在缩小的那半边里继续这一套流程，直至区间里只有一个元素，这就是我们查找的结果上面的内容里有两点需要注意，一个是中间元素mid怎么找。看起来无关紧要，但代码实现上的时候，这里会影响到后面的代码实现，且很容易出错；第二点是“查找结果”，我们的整数二分是一定会有一个结果的，但本身这个待查找元素x未必就在数组里。也就是说，即使数组里没有这个元素，我们用朴素的整数二分，不做其它的处理，还是会得到一个“伪答案”。所以实际看题目，如果题目说查找元素未必存在，就需要多一些处理逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF-1"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">代码模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8Bcheck%E5%87%BD%E6%95%B0%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E7%A7%8D%E5%B9%BF%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%83%E6%9C%AA%E5%BF%85%E5%B0%B1%E6%98%AF%E6%AF%94%E5%A4%A7%E5%B0%8F%E9%9C%80%E8%A6%81%E7%9C%8B%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82-%E7%84%B6%E5%90%8E%E4%B8%8A%E9%9D%A2%E6%98%AF%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%B8%A4%E7%A7%8D%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84mid%E5%8F%96%E6%B3%95%E6%98%AF%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E4%B8%94%E5%BD%B1%E5%93%8D%E5%88%B0%E5%90%8E%E9%9D%A2%E5%8C%BA%E9%97%B4%E7%9A%84%E7%BC%A9%E5%87%8F%E5%AE%9E%E9%99%85%E6%88%91%E4%BB%AC%E5%BA%94%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E9%9C%80%E8%A6%81%E6%AD%BB%E8%AE%B0%E7%A1%AC%E8%83%8C%E5%A5%97%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%A8%A1%E6%9D%BF%E6%AF%94%E8%BE%83%E8%87%AA%E7%84%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%98%AF%E6%88%91%E4%BB%AC%E4%BC%9A%E4%BE%9D%E6%8D%AE%E9%A2%98%E7%9B%AE%E6%9D%A1%E4%BB%B6%E5%85%88%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AAcheck%E5%B9%B6%E6%8A%8A%E5%8C%BA%E9%97%B4%E7%BC%A9%E5%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%86%99%E5%A5%BD%E4%B9%8B%E5%90%8E%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%86%8D%E5%8E%BB%E6%9B%B4%E6%94%B9mid%E7%9A%84%E5%8F%96%E6%B3%95%E8%80%8C%E4%B9%8B%E6%89%80%E4%BB%A5%E4%BC%9A%E6%9C%89%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8F%96%E6%B3%95%E4%B8%BB%E8%A6%81%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%9C%A8%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95%E4%B8%AD%E6%9C%89if-checkmid-l-mid%E8%BF%99%E4%B8%80%E8%A1%8C%E5%A6%82%E6%9E%9Cmid%E8%BF%98%E6%98%AF%E5%8F%96%E4%B8%BAl-r-1%E5%88%99%E5%BD%93l%E4%BB%85%E6%AF%94r%E5%B0%8F1%E7%9A%84%E6%97%B6%E5%80%99%E5%A6%82%E6%9E%9Ccheckmid%E6%88%90%E7%AB%8B%E4%BA%86lmid%E8%80%8C%E6%AD%A4%E6%97%B6mid%E8%BF%98%E6%98%AFl%E5%B0%B1%E9%99%B7%E5%85%A5%E4%BA%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BA%86%E6%89%80%E4%BB%A5%E5%BF%85%E9%A1%BB%E8%A6%81%E5%8A%A0%E4%B8%8A%E4%B8%80%E4%B8%AA1-%E6%95%85%E5%85%B6%E5%AE%9E%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99%E6%AD%A3%E5%A6%82%E4%B8%8A%E9%9D%A2%E6%89%80%E8%AF%B4%E4%BC%9A%E5%85%88%E6%8A%8Aif-else%E5%88%86%E6%94%AF%E5%86%99%E5%A5%BD%E5%8D%B3%E5%88%86%E6%94%AF%E7%BC%A9%E5%87%8F%E7%9A%84%E6%96%B9%E6%B3%95%E5%9B%A0%E4%B8%BA%E8%BF%99%E4%B8%AA%E6%98%AF%E6%A0%B9%E6%8D%AE%E9%A2%98%E6%84%8F%E6%9D%A5%E7%9A%84%E4%B9%8B%E5%90%8E%E6%88%91%E4%BB%AC%E8%A7%82%E5%AF%9F%E5%93%AA%E4%B8%AA%E8%BE%B9%E7%95%8C%E4%BC%9A%E8%A2%AB%E5%B9%85%E5%80%BC%E4%B8%BAmid%E5%A6%82%E6%9E%9C%E6%98%AFl-mid%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E5%B0%B1%E8%A6%81%E7%9C%8B%E5%A6%82%E6%9E%9Cmid-l-r-1%E9%82%A3%E4%B9%88%E5%BD%93l%E5%92%8Cr%E4%BB%85%E7%9B%B8%E5%B7%AE1%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%99%E4%B8%AAmid%E5%B0%B1%E6%98%AFl%E8%80%8C%E5%A6%82%E6%9E%9C%E5%8F%91%E7%94%9F%E4%BA%86lmid%E7%9A%84%E6%83%85%E5%86%B5%E5%B0%B1%E7%9B%B8%E5%BD%93%E4%BA%8El%E5%92%8Cr%E9%83%BD%E6%B2%A1%E5%8F%98%E5%88%99%E4%BC%9A%E4%B8%80%E7%9B%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%89%80%E4%BB%A5mid%E5%BA%94%E8%AF%A5%E6%9B%B4%E6%96%B0%E4%B8%BAl-r-1-1%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%8F%AF%E4%BB%A5%E5%88%86%E6%9E%90%E5%A6%82%E6%9E%9C%E6%98%AFr-mid%E5%88%99%E4%B8%8D%E9%9C%80%E8%A6%81%E5%8A%A01mid-l-r-1%E5%8D%B3%E5%8F%AF"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">对上面的代码简单说明一下。check函数其实是一种广义的函数，它未必就是比大小，需要看题目要求然后上面是实现了两种二分查找。可以看到，两种方法的mid取法是不一样的，且影响到后面区间的缩减。实际我们应用的时候，不需要死记硬背套这两个模板。比较自然的思路是，我们会依据题目条件，先写好一个check，并把区间缩减的方式写好。之后，我们可以再去更改mid的取法。而之所以会有两种不同的取法，主要是因为，在第二种方法中，有if (check(mid)) l &#x3D; mid;这一行。如果mid还是取为l
+ r &gt;&gt;
1，则当l仅比r小1的时候，如果check(mid)成立了，l&#x3D;mid，而此时mid还是l，就陷入了死循环了。所以必须要加上一个1故，其实写代码的时候，正如上面所说，会先把if
else分支写好（即分支缩减的方法，因为这个是根据题意来的）；之后，我们观察哪个边界会被幅值为mid：如果是l
&#x3D; mid，那么我们就要看，如果mid &#x3D; l + r &gt;&gt;
1，那么，当l和r仅相差1的时候，这个mid就是l，而如果发生了l&#x3D;mid的情况，就相当于l和r都没变，则会一直死循环，所以mid应该更新为l
+ r + 1 &gt;&gt; 1；类似的可以分析，如果是r &#x3D; mid，则不需要加1，mid &#x3D; l
+ r &gt;&gt; 1即可</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.2.2.浮点数二分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E6%88%91%E4%BB%AC%E4%B8%80%E8%88%AC%E8%A6%81%E5%81%9A%E7%9A%84%E5%B0%B1%E6%98%AF%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%8C%BA%E9%97%B4%E9%87%8C%E5%8E%BB%E9%80%BC%E8%BF%91%E6%9F%90%E4%B8%AA%E6%95%B0%E8%BF%99%E4%B8%AA%E6%95%B0%E5%8F%AF%E8%83%BD%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E6%B1%82%E5%87%BA%E6%9D%A5%E4%BE%8B%E5%A6%82%E6%B1%82%E6%9F%90%E4%B8%AA%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9%E8%BF%99%E4%B8%AA%E5%B0%B1%E7%AE%80%E5%8D%95%E5%A4%9A%E4%BA%86%E4%B8%8D%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5%E5%8F%AA%E9%9C%80%E8%A6%81%E4%BF%9D%E8%AF%81%E5%8D%95%E8%B0%83%E6%80%A7%E5%8D%B3%E5%8F%AF%E8%BF%98%E6%98%AF%E4%BB%A5%E4%B8%8A%E9%9D%A2%E6%8F%90%E5%88%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9%E4%B8%BA%E4%BE%8B%E5%BC%80%E4%B8%89%E6%AC%A1%E6%96%B9%E7%9A%84%E5%87%BD%E6%95%B0%E6%98%BE%E7%84%B6%E6%98%AF%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E7%9B%B4%E6%8E%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E5%B0%B1%E8%83%BD%E6%87%82%E4%BA%86-%E8%BF%98%E6%9C%89%E4%B8%AA%E9%97%AE%E9%A2%98%E5%B0%B1%E6%98%AFcpp%E4%B8%AD%E8%A6%81%E7%94%A8double%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BDfloat%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E5%B7%B2%E7%BB%8F%E8%A6%81%E6%B1%82%E4%BF%9D%E7%95%996%E4%BD%8D%E5%B0%8F%E6%95%B0%E5%88%99%E9%97%B4%E9%9A%94%E6%9C%80%E5%A4%A7%E4%B9%9F%E8%A6%81%E5%88%B01e-8%E7%BA%A7%E5%88%AB%E4%BA%86%E7%84%B6%E8%80%8Cfloat%E8%83%BD%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97%E5%A4%A7%E7%BA%A6%E6%98%AF6-7%E4%BD%8D%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E5%B7%B2%E7%BB%8F%E4%B8%8D%E5%A4%AA%E5%A4%9F%E4%BA%86double%E8%83%BD%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97%E5%A4%A7%E7%BA%A6%E6%98%AF15-16%E4%BD%8D%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E5%80%92%E6%98%AF%E5%A4%9F%E7%94%A8%E8%BE%93%E5%85%A5n%E4%BB%8B%E4%BA%8E-10000%E5%92%8C10000%E4%B9%8B%E9%97%B4"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">这种情况，我们一般要做的就是在一个区间里，去逼近某个数，这个数可能不能直接求出来。例如，求某个数的三次方根。这个就简单多了，不需要考虑什么边界情况。只需要保证单调性即可。还是以上面提到的三次方根为例。开三次方的函数显然是单调递增的。直接看代码就能懂了还有个问题，就是，cpp中，要用double类型，不能float类型。题目已经要求保留6位小数，则间隔最大也要到1e-8级别了。然而float能表示的有效数字大约是6-7位十进制数，已经不太够了；double能表示的有效数字大约是15-16位十进制数，倒是够用（输入n介于-10000和10000之间）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%B8%A6%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8Bpython%E4%B8%AD%E7%9A%84.formatf-string%E7%9A%84%E7%94%A8%E6%B3%95.format%E6%98%AFpython%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E4%B8%80%E7%A7%8D%E8%AF%AD%E6%B3%95%E4%B9%9F%E6%98%AF%E6%AF%94%E8%BE%83%E8%80%81%E7%9A%84%E4%B8%80%E7%A7%8D%E5%85%88%E4%BA%8Ef-string%E5%87%BA%E7%8E%B0"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">顺带说明一下python中的.format&#x2F;f-string的用法。.format是python的一种字符串格式化的一种语法（也是比较老的一种，先于f-string出现）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E4%B8%8A%E9%9D%A2%E7%94%A8%E5%88%B0%E7%9A%84.6f%E4%B8%BA%E4%BE%8B%E6%98%AF%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%98%AF%E4%B8%80%E4%B8%AA%E8%B5%B7%E5%A7%8B%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%AE%83%E5%90%8E%E9%9D%A2%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E6%9C%9F%E6%9C%9B%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%80%8C%E8%90%BD%E5%9B%9E%E5%88%B0%E8%BF%99%E9%87%8C.6f%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E5%B8%8C%E6%9C%9B%E7%9A%84%E6%A0%BC%E5%BC%8F.%E6%98%AF%E7%B2%BE%E5%BA%A6%E6%8C%87%E7%A4%BA%E7%AC%A66%E4%BB%A3%E8%A1%A8%E8%A6%81%E4%BF%9D%E7%95%99%E7%9A%84%E5%B0%8F%E6%95%B0%E4%BD%8D%E6%95%B0%E6%89%80%E4%BB%A5%E8%BF%99%E9%87%8C.6f%E5%B0%B1%E4%BB%A3%E8%A1%A8%E6%88%91%E4%BB%AC%E6%9C%9F%E6%9C%9B%E7%9A%84%E6%A0%BC%E5%BC%8F%E6%98%AF%E4%BF%9D%E7%95%996%E4%BD%8D%E5%B0%8F%E6%95%B0"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">以上面用到的{:.6f}为例。{}是占位符，:是一个起始说明符，它后面就是我们期望的格式。而落回到这里，&quot;.6f&quot;就是我们希望的格式，&quot;.&quot;是精度指示符，&quot;6&quot;代表要保留的小数位数，所以这里&quot;.6f&quot;就代表我们期望的格式是保留6位小数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%B3%E4%BA%8Ef-string%E5%AE%83%E6%98%AF%E5%9C%A8python3.6%E4%B9%8B%E5%90%8E%E6%89%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B9%9F%E6%98%AF%E7%94%A8%E4%BA%8E%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AE%83%E7%9B%B8%E6%AF%94%E4%BA%8E.format%E7%89%B9%E7%82%B9%E5%B0%B1%E6%98%AF%E6%9B%B4%E5%8A%A0%E7%AE%80%E6%B4%81%E5%9C%A8%E6%AD%A4%E5%A4%84%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%BF%98%E6%98%AF%E5%B8%8C%E6%9C%9B%E8%BE%93%E5%87%BA%E4%BF%9D%E7%95%996%E4%BD%8D%E5%B0%8F%E6%95%B0%E7%94%A8f-string%E5%88%99%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E8%A1%A8%E7%A4%BAfl.6f%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E7%9B%B4%E6%8E%A5%E6%8A%8A%E8%A6%81%E8%BE%93%E5%87%BA%E7%9A%84%E5%8F%98%E9%87%8Fl%E6%94%BE%E5%88%B0%E9%87%8C%E9%9D%A2%E8%87%B3%E4%BA%8E%E5%92%8C.6f%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8A%9F%E8%83%BD%E5%88%99%E6%98%AF%E5%92%8C%E4%B8%8A%E9%9D%A2%E4%B8%80%E6%A0%B7"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">至于f-string，它是在python3.6之后才出现的，也是用于控制字符串格式的。它相比于.format，特点就是更加简洁。在此处，如果我们还是希望输出保留6位小数，用f-string，则可以这样表示：f{l:.6f}。这里我们直接把要输出的变量l放到{}里面，至于&quot;:&quot;和&quot;.6f&quot;的用法和功能，则是和上面一样</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bluemouse</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bluemouse</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
