<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blueeemouse.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="首先，选择这个主题，主要是因为，调研了一些文献之后，发现，现在的大多数论文，都是在repo-level task上做文章（不管是repo-level code generation，code completion或者是issue fixing之类的），因为llm在单文件上的能力确实很够用了，但在多文件，尤其是大到repo-level的时候，就不太够了。有提出multi-agents来分解任务">
<meta property="og:type" content="article">
<meta property="og:title" content="bluemouse&#39;s blog">
<meta property="og:url" content="https://blueeemouse.github.io/2025/07/17/%E8%AE%BA%E6%96%87%E5%92%8C%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/nlp/llm/llm4code/%E9%80%89%E6%8B%A9%E4%B8%BB%E9%A2%98%EF%BC%9A%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E7%90%86%E8%A7%A3/index.html">
<meta property="og:site_name" content="bluemouse&#39;s blog">
<meta property="og:description" content="首先，选择这个主题，主要是因为，调研了一些文献之后，发现，现在的大多数论文，都是在repo-level task上做文章（不管是repo-level code generation，code completion或者是issue fixing之类的），因为llm在单文件上的能力确实很够用了，但在多文件，尤其是大到repo-level的时候，就不太够了。有提出multi-agents来分解任务">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-07-17T06:18:52.379Z">
<meta property="article:modified_time" content="2025-07-17T07:23:45.059Z">
<meta property="article:author" content="bluemouse">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blueeemouse.github.io/2025/07/17/%E8%AE%BA%E6%96%87%E5%92%8C%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/nlp/llm/llm4code/%E9%80%89%E6%8B%A9%E4%B8%BB%E9%A2%98%EF%BC%9A%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E7%90%86%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title> | bluemouse's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bluemouse's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueeemouse.github.io/2025/07/17/%E8%AE%BA%E6%96%87%E5%92%8C%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/nlp/llm/llm4code/%E9%80%89%E6%8B%A9%E4%B8%BB%E9%A2%98%EF%BC%9A%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-17 14:18:52 / Modified: 15:23:45" itemprop="dateCreated datePublished" datetime="2025-07-17T14:18:52+08:00">2025-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="首先选择这个主题主要是因为调研了一些文献之后发现现在的大多数论文都是在repo-level-task上做文章不管是repo-level-code-generationcode-completion或者是issue-fixing之类的因为llm在单文件上的能力确实很够用了但在多文件尤其是大到repo-level的时候就不太够了有提出multi-agents来分解任务的有提出新的benchmark来测量模型能力边界的也有提出rag框架来辅助理解的不过总而言之repo-level的task一定都要求模型能有一个对repo整体的理解这方面的研究其实相对有些缺失例如repo-level-code-generation上有很多设计了agent的方法的论文比如一篇比较早的pku的self-collaboration-code-generation-via-chatgpt它其实就是对同一个llm施加了不同的prompt让它扮演不同的角色至于扮演哪些角色它则是基于软件开发理论设计了三个角色analystcodingtesting然而具体到analyst上的时候也没有专门设计什么方法帮助llm进行理解类似的又比如codeagent这篇论文提出设计专用于repo-level-code-generation的agent的框架且是首次提出然而它也只是给llm加上了工具并没有专门设计让llm从整体上理解repo的方法-这一块现在有少部分在做吧比较多的会用到graph因为理解repo的关键在于理解repo里各个代码文件之间的复杂的关系这种关系就可以考虑用graph来构建比如比较新的一篇code-graph-modelscgm6月份以及参考论文里的repograph它们就都是把repo给构建成graph再拿去给llm进行处理本质上可以认为是graph的边的连接让文件代码之间的相互关系更加凸显了如果只是把repo给展平了一股脑拿给llm那可能repo比较小的时候还能把握到关系repo大了就不太行了">首先，选择这个主题，主要是因为，调研了一些文献之后，发现，现在的大多数论文，都是在repo-level
task上做文章（不管是repo-level code generation，code
completion或者是issue
fixing之类的），因为llm在单文件上的能力确实很够用了，但在多文件，尤其是大到repo-level的时候，就不太够了。有提出multi-agents来分解任务的，有提出新的benchmark来测量模型能力边界的，也有提出RAG框架来辅助理解的。不过总而言之，repo-level的task，一定都要求模型能有一个对repo整体的理解。这方面的研究其实相对有些缺失。例如，repo-level
code
generation上，有很多设计了agent的方法的论文，比如一篇比较早的，pku的Self-Collaboration
Code Generation via
ChatGPT，它其实就是对同一个llm，施加了不同的prompt，让它扮演不同的角色；至于扮演哪些角色，它则是基于软件开发理论，设计了三个角色（analyst，coding，testing）。然而具体到analyst上的时候，也没有专门设计什么方法帮助llm进行理解；类似的，又比如CodeAgent，这篇论文提出设计专用于repo-level
code
generation的agent的框架，且是首次提出，然而它也只是给llm加上了工具，并没有专门设计让llm从整体上理解repo的方法<br>这一块现在有少部分在做吧，比较多的会用到graph。因为，理解repo的关键在于理解repo里各个代码、文件之间的复杂的关系，这种关系就可以考虑用graph来构建。比如比较新的一篇Code
Graph
Models（CGM）（6月份），以及参考论文里的RepoGraph，它们就都是把repo给构建成graph，再拿去给llm进行处理。本质上，可以认为是graph的边的连接，让文件/代码之间的相互关系更加凸显了。如果只是把repo给展平了，一股脑拿给llm，那可能repo比较小的时候，还能把握到关系；repo大了，就不太行了</h2>
<h2 id="而既然用了graph的结果来表征repo是否考虑把gnn也拿过来应用因为gnn有可能处理graph会处理得更好现在大多还是只是把graph拿给transformer因此需要对graph做一些处理比如把各个节点先编码成text-embedding再投影到llm的embedding-space转成llm里的token和正常的文本输入一起处理-另外这套用graph理解repo的方法其实也可以和各种基于agent的方法结合吧如果能有更好的对repo的理解agent进行动作的时候也更加不容易出错因此积累的错误会更少同时agent更好地与repo进行交互得到更好的理解也有助于辅助改进对repo的整体理解且二者应该也没有太多矛盾的地方所以它们既有结合的价值也有结合的可能似乎是值得一试的">而既然用了graph的结果来表征repo，是否考虑把GNN也拿过来应用？因为GNN有可能处理graph会处理得更好。现在大多还是只是把graph拿给transformer，因此需要对graph做一些处理，比如把各个节点先编码成text
embedding，再投影到llm的embedding
space，转成llm里的token，和正常的文本输入一起处理<br>另外，这套用graph理解repo的方法，其实也可以和各种基于agent的方法结合吧。如果能有更好的对repo的理解，agent进行动作的时候也更加不容易出错，因此积累的错误会更少；同时agent更好地与repo进行交互，得到更好的理解，也有助于辅助改进对repo的整体理解。且二者应该也没有太多矛盾的地方。所以它们既有结合的价值，也有结合的可能，似乎是值得一试的</h2>
<h2 id="英文版">英文版</h2>
<h3 id="when-delving-into-the-understanding-and-application-of-large-language-models-llms-for-software-code-repositories-i-have-chosen-to-focus-on-the-topic-of-agent---based-code-repository-comprehension.">When
delving into the understanding and application of Large Language Models
(LLMs) for software code repositories, I have chosen to focus on the
topic of "Agent - based Code Repository Comprehension".</h3>
<h3 id="through-research-on-relevant-literature-ive-noticed-that-most-current-research-papers-concentrate-on-repository---level-repo---level-tasks.-given-that-llms-have-demonstrated-strong-capabilities-in-single---file-processing-they-fall-short-when-dealing-with-multi---file-scenarios-especially-large---scale-repo---level-tasks.-to-address-this-issue-the-academic-community-has-proposed-various-methods-including-using-multi---agents-to-decompose-tasks-constructing-new-benchmarks-to-evaluate-the-models-capabilities-and-introducing-the-retrieve-augmented-generation-rag-framework-to-assist-model-understanding.-however-regardless-of-the-approach-repo---level-tasks-all-impose-a-key-requirement-on-the-model-the-ability-to-deeply-understand-the-code-repository-as-a-whole.-currently-research-in-this-area-is-relatively-scarce.">Through
research on relevant literature, I've noticed that most current research
papers concentrate on repository - level (repo - level) tasks. Given
that LLMs have demonstrated strong capabilities in single - file
processing, they fall short when dealing with multi - file scenarios,
especially large - scale repo - level tasks. To address this issue, the
academic community has proposed various methods, including using multi -
agents to decompose tasks, constructing new benchmarks to evaluate the
model's capabilities, and introducing the Retrieve Augmented Generation
(RAG) framework to assist model understanding. However, regardless of
the approach, repo - level tasks all impose a key requirement on the
model: the ability to deeply understand the code repository as a whole.
Currently, research in this area is relatively scarce.</h3>
<h3 id="take-repo---level-code-generation-as-an-example.-many-papers-have-proposed-agent---based-methods.-for-instance-an-early-study-by-peking-university-self---collaboration-code-generation-via-chatgpt-based-on-software-development-theory-sets-different-prompts-for-the-same-llm-enabling-it-to-play-three-roles-analyst-coder-and-tester.-however-in-the-analyst-role-there-is-no-dedicated-method-to-help-the-llm-understand-the-code-repository.-similarly-the-paper-codeagent-first-proposed-an-agent-framework-for-repo---level-code-generation.-nevertheless-it-merely-adds-tools-to-the-llm-and-lacks-a-method-for-the-llm-to-comprehensively-understand-the-code-repository.">Take
repo - level code generation as an example. Many papers have proposed
agent - based methods. For instance, an early study by Peking
University, "Self - Collaboration Code Generation via ChatGPT", based on
software development theory, sets different prompts for the same LLM,
enabling it to play three roles: analyst, coder, and tester. However, in
the analyst role, there is no dedicated method to help the LLM
understand the code repository. Similarly, the paper "CodeAgent" first
proposed an agent framework for repo - level code generation.
Nevertheless, it merely adds tools to the LLM and lacks a method for the
LLM to comprehensively understand the code repository.</h3>
<h3 id="currently-a-small-number-of-studies-attempt-to-use-graphs-to-solve-this-problem.-since-the-core-of-understanding-a-code-repository-lies-in-grasping-the-complex-relationships-among-its-various-codes-and-files-and-graph-structures-can-effectively-model-these-relationships.-for-example-code-graph-models-cgm-published-in-june-this-year-and-the-reference-paper-repograph-both-construct-the-code-repository-as-a-graph-structure-and-then-feed-it-to-the-llm-for-processing.-essentially-the-edges-in-the-graph-make-the-relationships-between-files-and-codes-more-prominent.-in-contrast-if-the-code-repository-is-simply-flattened-and-directly-input-to-the-llm-when-the-repository-is-small-the-model-may-still-capture-some-relationships.-but-as-the-repository-size-increases-the-model-becomes-less-effective.">Currently,
a small number of studies attempt to use graphs to solve this problem.
Since the core of understanding a code repository lies in grasping the
complex relationships among its various codes and files, and graph
structures can effectively model these relationships. For example, "Code
Graph Models (CGM)" published in June this year and the reference paper
"RepoGraph" both construct the code repository as a graph structure and
then feed it to the LLM for processing. Essentially, the edges in the
graph make the relationships between files and codes more prominent. In
contrast, if the code repository is simply flattened and directly input
to the LLM, when the repository is small, the model may still capture
some relationships. But as the repository size increases, the model
becomes less effective.</h3>
<h3 id="since-the-result-of-using-graphs-to-represent-the-code-repository-is-considered-could-introducing-graph-neural-networks-gnns-bring-better-results-because-gnns-have-inherent-advantages-in-processing-graph---structured-data.-currently-most-studies-only-provide-graph-data-to-transformers-which-requires-additional-processing-of-the-graph.-for-example-each-node-is-first-encoded-into-text-embeddings-then-projected-into-the-llms-embedding-space-and-converted-into-tokens-in-the-llm-to-be-processed-together-with-normal-text-input.">Since
the result of using graphs to represent the code repository is
considered, could introducing Graph Neural Networks (GNNs) bring better
results? Because GNNs have inherent advantages in processing graph -
structured data. Currently, most studies only provide graph data to
Transformers, which requires additional processing of the graph. For
example, each node is first encoded into text embeddings, then projected
into the LLM's embedding space, and converted into tokens in the LLM to
be processed together with normal text input.</h3>
<h3 id="in-addition-this-graph---based-code-repository-understanding-method-has-the-potential-to-be-combined-with-various-agent---based-methods.-deeper-understanding-of-the-code-repository-can-reduce-errors-when-agents-perform-actions-and-decrease-error-accumulation.-at-the-same-time-the-effective-interaction-between-agents-and-the-code-repository-also-helps-to-further-improve-the-overall-understanding-of-the-code-repository.-moreover-these-two-methods-do-not-conflict-in-principle.-therefore-they-not-only-have-the-value-of-combination-but-also-the-feasibility-in-practice-which-is-worthy-of-in---depth-exploration.">In
addition, this graph - based code repository understanding method has
the potential to be combined with various agent - based methods. Deeper
understanding of the code repository can reduce errors when agents
perform actions and decrease error accumulation. At the same time, the
effective interaction between agents and the code repository also helps
to further improve the overall understanding of the code repository.
Moreover, these two methods do not conflict in principle. Therefore,
they not only have the value of combination but also the feasibility in
practice, which is worthy of in - depth exploration.</h3>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/07/17/%E8%AE%BA%E6%96%87%E5%92%8C%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/nlp/llm/llm4code/CodeAgent%EF%BC%9AEnhancing%20Code%20Generation%20with%20Tool-Integrated%20Agent%20Systems%20for%20Real-World%20Repo-level%20Coding%20Challenges/" rel="prev" title="CodeAgent：Enhancing Code Generation with Tool-Integrated Agent Systems for Real-World Repo-level Coding Challenges">
      <i class="fa fa-chevron-left"></i> CodeAgent：Enhancing Code Generation with Tool-Integrated Agent Systems for Real-World Repo-level Coding Challenges
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/07/17/%E8%AE%BA%E6%96%87%E5%92%8C%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/nlp/llm/llm4code/Multi-Agent%20Collaboration%20via%20Cross-Team%20Orchestration/" rel="next" title="Multi-Agent Collaboration via Cross-Team Orchestration">
      Multi-Agent Collaboration via Cross-Team Orchestration <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A6%96%E5%85%88%E9%80%89%E6%8B%A9%E8%BF%99%E4%B8%AA%E4%B8%BB%E9%A2%98%E4%B8%BB%E8%A6%81%E6%98%AF%E5%9B%A0%E4%B8%BA%E8%B0%83%E7%A0%94%E4%BA%86%E4%B8%80%E4%BA%9B%E6%96%87%E7%8C%AE%E4%B9%8B%E5%90%8E%E5%8F%91%E7%8E%B0%E7%8E%B0%E5%9C%A8%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0%E8%AE%BA%E6%96%87%E9%83%BD%E6%98%AF%E5%9C%A8repo-level-task%E4%B8%8A%E5%81%9A%E6%96%87%E7%AB%A0%E4%B8%8D%E7%AE%A1%E6%98%AFrepo-level-code-generationcode-completion%E6%88%96%E8%80%85%E6%98%AFissue-fixing%E4%B9%8B%E7%B1%BB%E7%9A%84%E5%9B%A0%E4%B8%BAllm%E5%9C%A8%E5%8D%95%E6%96%87%E4%BB%B6%E4%B8%8A%E7%9A%84%E8%83%BD%E5%8A%9B%E7%A1%AE%E5%AE%9E%E5%BE%88%E5%A4%9F%E7%94%A8%E4%BA%86%E4%BD%86%E5%9C%A8%E5%A4%9A%E6%96%87%E4%BB%B6%E5%B0%A4%E5%85%B6%E6%98%AF%E5%A4%A7%E5%88%B0repo-level%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E4%B8%8D%E5%A4%AA%E5%A4%9F%E4%BA%86%E6%9C%89%E6%8F%90%E5%87%BAmulti-agents%E6%9D%A5%E5%88%86%E8%A7%A3%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%9C%89%E6%8F%90%E5%87%BA%E6%96%B0%E7%9A%84benchmark%E6%9D%A5%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%9E%8B%E8%83%BD%E5%8A%9B%E8%BE%B9%E7%95%8C%E7%9A%84%E4%B9%9F%E6%9C%89%E6%8F%90%E5%87%BArag%E6%A1%86%E6%9E%B6%E6%9D%A5%E8%BE%85%E5%8A%A9%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%8D%E8%BF%87%E6%80%BB%E8%80%8C%E8%A8%80%E4%B9%8Brepo-level%E7%9A%84task%E4%B8%80%E5%AE%9A%E9%83%BD%E8%A6%81%E6%B1%82%E6%A8%A1%E5%9E%8B%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AF%B9repo%E6%95%B4%E4%BD%93%E7%9A%84%E7%90%86%E8%A7%A3%E8%BF%99%E6%96%B9%E9%9D%A2%E7%9A%84%E7%A0%94%E7%A9%B6%E5%85%B6%E5%AE%9E%E7%9B%B8%E5%AF%B9%E6%9C%89%E4%BA%9B%E7%BC%BA%E5%A4%B1%E4%BE%8B%E5%A6%82repo-level-code-generation%E4%B8%8A%E6%9C%89%E5%BE%88%E5%A4%9A%E8%AE%BE%E8%AE%A1%E4%BA%86agent%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BA%E6%96%87%E6%AF%94%E5%A6%82%E4%B8%80%E7%AF%87%E6%AF%94%E8%BE%83%E6%97%A9%E7%9A%84pku%E7%9A%84self-collaboration-code-generation-via-chatgpt%E5%AE%83%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E5%AF%B9%E5%90%8C%E4%B8%80%E4%B8%AAllm%E6%96%BD%E5%8A%A0%E4%BA%86%E4%B8%8D%E5%90%8C%E7%9A%84prompt%E8%AE%A9%E5%AE%83%E6%89%AE%E6%BC%94%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%92%E8%89%B2%E8%87%B3%E4%BA%8E%E6%89%AE%E6%BC%94%E5%93%AA%E4%BA%9B%E8%A7%92%E8%89%B2%E5%AE%83%E5%88%99%E6%98%AF%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%89%E4%B8%AA%E8%A7%92%E8%89%B2analystcodingtesting%E7%84%B6%E8%80%8C%E5%85%B7%E4%BD%93%E5%88%B0analyst%E4%B8%8A%E7%9A%84%E6%97%B6%E5%80%99%E4%B9%9F%E6%B2%A1%E6%9C%89%E4%B8%93%E9%97%A8%E8%AE%BE%E8%AE%A1%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%B8%AE%E5%8A%A9llm%E8%BF%9B%E8%A1%8C%E7%90%86%E8%A7%A3%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%8F%88%E6%AF%94%E5%A6%82codeagent%E8%BF%99%E7%AF%87%E8%AE%BA%E6%96%87%E6%8F%90%E5%87%BA%E8%AE%BE%E8%AE%A1%E4%B8%93%E7%94%A8%E4%BA%8Erepo-level-code-generation%E7%9A%84agent%E7%9A%84%E6%A1%86%E6%9E%B6%E4%B8%94%E6%98%AF%E9%A6%96%E6%AC%A1%E6%8F%90%E5%87%BA%E7%84%B6%E8%80%8C%E5%AE%83%E4%B9%9F%E5%8F%AA%E6%98%AF%E7%BB%99llm%E5%8A%A0%E4%B8%8A%E4%BA%86%E5%B7%A5%E5%85%B7%E5%B9%B6%E6%B2%A1%E6%9C%89%E4%B8%93%E9%97%A8%E8%AE%BE%E8%AE%A1%E8%AE%A9llm%E4%BB%8E%E6%95%B4%E4%BD%93%E4%B8%8A%E7%90%86%E8%A7%A3repo%E7%9A%84%E6%96%B9%E6%B3%95-%E8%BF%99%E4%B8%80%E5%9D%97%E7%8E%B0%E5%9C%A8%E6%9C%89%E5%B0%91%E9%83%A8%E5%88%86%E5%9C%A8%E5%81%9A%E5%90%A7%E6%AF%94%E8%BE%83%E5%A4%9A%E7%9A%84%E4%BC%9A%E7%94%A8%E5%88%B0graph%E5%9B%A0%E4%B8%BA%E7%90%86%E8%A7%A3repo%E7%9A%84%E5%85%B3%E9%94%AE%E5%9C%A8%E4%BA%8E%E7%90%86%E8%A7%A3repo%E9%87%8C%E5%90%84%E4%B8%AA%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BF%99%E7%A7%8D%E5%85%B3%E7%B3%BB%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E7%94%A8graph%E6%9D%A5%E6%9E%84%E5%BB%BA%E6%AF%94%E5%A6%82%E6%AF%94%E8%BE%83%E6%96%B0%E7%9A%84%E4%B8%80%E7%AF%87code-graph-modelscgm6%E6%9C%88%E4%BB%BD%E4%BB%A5%E5%8F%8A%E5%8F%82%E8%80%83%E8%AE%BA%E6%96%87%E9%87%8C%E7%9A%84repograph%E5%AE%83%E4%BB%AC%E5%B0%B1%E9%83%BD%E6%98%AF%E6%8A%8Arepo%E7%BB%99%E6%9E%84%E5%BB%BA%E6%88%90graph%E5%86%8D%E6%8B%BF%E5%8E%BB%E7%BB%99llm%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%8F%AF%E4%BB%A5%E8%AE%A4%E4%B8%BA%E6%98%AFgraph%E7%9A%84%E8%BE%B9%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%AE%A9%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB%E6%9B%B4%E5%8A%A0%E5%87%B8%E6%98%BE%E4%BA%86%E5%A6%82%E6%9E%9C%E5%8F%AA%E6%98%AF%E6%8A%8Arepo%E7%BB%99%E5%B1%95%E5%B9%B3%E4%BA%86%E4%B8%80%E8%82%A1%E8%84%91%E6%8B%BF%E7%BB%99llm%E9%82%A3%E5%8F%AF%E8%83%BDrepo%E6%AF%94%E8%BE%83%E5%B0%8F%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%98%E8%83%BD%E6%8A%8A%E6%8F%A1%E5%88%B0%E5%85%B3%E7%B3%BBrepo%E5%A4%A7%E4%BA%86%E5%B0%B1%E4%B8%8D%E5%A4%AA%E8%A1%8C%E4%BA%86"><span class="nav-number">1.</span> <span class="nav-text">首先，选择这个主题，主要是因为，调研了一些文献之后，发现，现在的大多数论文，都是在repo-level
task上做文章（不管是repo-level code generation，code
completion或者是issue
fixing之类的），因为llm在单文件上的能力确实很够用了，但在多文件，尤其是大到repo-level的时候，就不太够了。有提出multi-agents来分解任务的，有提出新的benchmark来测量模型能力边界的，也有提出RAG框架来辅助理解的。不过总而言之，repo-level的task，一定都要求模型能有一个对repo整体的理解。这方面的研究其实相对有些缺失。例如，repo-level
code
generation上，有很多设计了agent的方法的论文，比如一篇比较早的，pku的Self-Collaboration
Code Generation via
ChatGPT，它其实就是对同一个llm，施加了不同的prompt，让它扮演不同的角色；至于扮演哪些角色，它则是基于软件开发理论，设计了三个角色（analyst，coding，testing）。然而具体到analyst上的时候，也没有专门设计什么方法帮助llm进行理解；类似的，又比如CodeAgent，这篇论文提出设计专用于repo-level
code
generation的agent的框架，且是首次提出，然而它也只是给llm加上了工具，并没有专门设计让llm从整体上理解repo的方法这一块现在有少部分在做吧，比较多的会用到graph。因为，理解repo的关键在于理解repo里各个代码、文件之间的复杂的关系，这种关系就可以考虑用graph来构建。比如比较新的一篇Code
Graph
Models（CGM）（6月份），以及参考论文里的RepoGraph，它们就都是把repo给构建成graph，再拿去给llm进行处理。本质上，可以认为是graph的边的连接，让文件&#x2F;代码之间的相互关系更加凸显了。如果只是把repo给展平了，一股脑拿给llm，那可能repo比较小的时候，还能把握到关系；repo大了，就不太行了</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%80%8C%E6%97%A2%E7%84%B6%E7%94%A8%E4%BA%86graph%E7%9A%84%E7%BB%93%E6%9E%9C%E6%9D%A5%E8%A1%A8%E5%BE%81repo%E6%98%AF%E5%90%A6%E8%80%83%E8%99%91%E6%8A%8Agnn%E4%B9%9F%E6%8B%BF%E8%BF%87%E6%9D%A5%E5%BA%94%E7%94%A8%E5%9B%A0%E4%B8%BAgnn%E6%9C%89%E5%8F%AF%E8%83%BD%E5%A4%84%E7%90%86graph%E4%BC%9A%E5%A4%84%E7%90%86%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%8E%B0%E5%9C%A8%E5%A4%A7%E5%A4%9A%E8%BF%98%E6%98%AF%E5%8F%AA%E6%98%AF%E6%8A%8Agraph%E6%8B%BF%E7%BB%99transformer%E5%9B%A0%E6%AD%A4%E9%9C%80%E8%A6%81%E5%AF%B9graph%E5%81%9A%E4%B8%80%E4%BA%9B%E5%A4%84%E7%90%86%E6%AF%94%E5%A6%82%E6%8A%8A%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9%E5%85%88%E7%BC%96%E7%A0%81%E6%88%90text-embedding%E5%86%8D%E6%8A%95%E5%BD%B1%E5%88%B0llm%E7%9A%84embedding-space%E8%BD%AC%E6%88%90llm%E9%87%8C%E7%9A%84token%E5%92%8C%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E4%B8%80%E8%B5%B7%E5%A4%84%E7%90%86-%E5%8F%A6%E5%A4%96%E8%BF%99%E5%A5%97%E7%94%A8graph%E7%90%86%E8%A7%A3repo%E7%9A%84%E6%96%B9%E6%B3%95%E5%85%B6%E5%AE%9E%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%92%8C%E5%90%84%E7%A7%8D%E5%9F%BA%E4%BA%8Eagent%E7%9A%84%E6%96%B9%E6%B3%95%E7%BB%93%E5%90%88%E5%90%A7%E5%A6%82%E6%9E%9C%E8%83%BD%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%AF%B9repo%E7%9A%84%E7%90%86%E8%A7%A3agent%E8%BF%9B%E8%A1%8C%E5%8A%A8%E4%BD%9C%E7%9A%84%E6%97%B6%E5%80%99%E4%B9%9F%E6%9B%B4%E5%8A%A0%E4%B8%8D%E5%AE%B9%E6%98%93%E5%87%BA%E9%94%99%E5%9B%A0%E6%AD%A4%E7%A7%AF%E7%B4%AF%E7%9A%84%E9%94%99%E8%AF%AF%E4%BC%9A%E6%9B%B4%E5%B0%91%E5%90%8C%E6%97%B6agent%E6%9B%B4%E5%A5%BD%E5%9C%B0%E4%B8%8Erepo%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%E5%BE%97%E5%88%B0%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%90%86%E8%A7%A3%E4%B9%9F%E6%9C%89%E5%8A%A9%E4%BA%8E%E8%BE%85%E5%8A%A9%E6%94%B9%E8%BF%9B%E5%AF%B9repo%E7%9A%84%E6%95%B4%E4%BD%93%E7%90%86%E8%A7%A3%E4%B8%94%E4%BA%8C%E8%80%85%E5%BA%94%E8%AF%A5%E4%B9%9F%E6%B2%A1%E6%9C%89%E5%A4%AA%E5%A4%9A%E7%9F%9B%E7%9B%BE%E7%9A%84%E5%9C%B0%E6%96%B9%E6%89%80%E4%BB%A5%E5%AE%83%E4%BB%AC%E6%97%A2%E6%9C%89%E7%BB%93%E5%90%88%E7%9A%84%E4%BB%B7%E5%80%BC%E4%B9%9F%E6%9C%89%E7%BB%93%E5%90%88%E7%9A%84%E5%8F%AF%E8%83%BD%E4%BC%BC%E4%B9%8E%E6%98%AF%E5%80%BC%E5%BE%97%E4%B8%80%E8%AF%95%E7%9A%84"><span class="nav-number">2.</span> <span class="nav-text">而既然用了graph的结果来表征repo，是否考虑把GNN也拿过来应用？因为GNN有可能处理graph会处理得更好。现在大多还是只是把graph拿给transformer，因此需要对graph做一些处理，比如把各个节点先编码成text
embedding，再投影到llm的embedding
space，转成llm里的token，和正常的文本输入一起处理另外，这套用graph理解repo的方法，其实也可以和各种基于agent的方法结合吧。如果能有更好的对repo的理解，agent进行动作的时候也更加不容易出错，因此积累的错误会更少；同时agent更好地与repo进行交互，得到更好的理解，也有助于辅助改进对repo的整体理解。且二者应该也没有太多矛盾的地方。所以它们既有结合的价值，也有结合的可能，似乎是值得一试的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8B%B1%E6%96%87%E7%89%88"><span class="nav-number">3.</span> <span class="nav-text">英文版</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#when-delving-into-the-understanding-and-application-of-large-language-models-llms-for-software-code-repositories-i-have-chosen-to-focus-on-the-topic-of-agent---based-code-repository-comprehension."><span class="nav-number">3.1.</span> <span class="nav-text">When
delving into the understanding and application of Large Language Models
(LLMs) for software code repositories, I have chosen to focus on the
topic of &quot;Agent - based Code Repository Comprehension&quot;.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#through-research-on-relevant-literature-ive-noticed-that-most-current-research-papers-concentrate-on-repository---level-repo---level-tasks.-given-that-llms-have-demonstrated-strong-capabilities-in-single---file-processing-they-fall-short-when-dealing-with-multi---file-scenarios-especially-large---scale-repo---level-tasks.-to-address-this-issue-the-academic-community-has-proposed-various-methods-including-using-multi---agents-to-decompose-tasks-constructing-new-benchmarks-to-evaluate-the-models-capabilities-and-introducing-the-retrieve-augmented-generation-rag-framework-to-assist-model-understanding.-however-regardless-of-the-approach-repo---level-tasks-all-impose-a-key-requirement-on-the-model-the-ability-to-deeply-understand-the-code-repository-as-a-whole.-currently-research-in-this-area-is-relatively-scarce."><span class="nav-number">3.2.</span> <span class="nav-text">Through
research on relevant literature, I&#39;ve noticed that most current research
papers concentrate on repository - level (repo - level) tasks. Given
that LLMs have demonstrated strong capabilities in single - file
processing, they fall short when dealing with multi - file scenarios,
especially large - scale repo - level tasks. To address this issue, the
academic community has proposed various methods, including using multi -
agents to decompose tasks, constructing new benchmarks to evaluate the
model&#39;s capabilities, and introducing the Retrieve Augmented Generation
(RAG) framework to assist model understanding. However, regardless of
the approach, repo - level tasks all impose a key requirement on the
model: the ability to deeply understand the code repository as a whole.
Currently, research in this area is relatively scarce.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#take-repo---level-code-generation-as-an-example.-many-papers-have-proposed-agent---based-methods.-for-instance-an-early-study-by-peking-university-self---collaboration-code-generation-via-chatgpt-based-on-software-development-theory-sets-different-prompts-for-the-same-llm-enabling-it-to-play-three-roles-analyst-coder-and-tester.-however-in-the-analyst-role-there-is-no-dedicated-method-to-help-the-llm-understand-the-code-repository.-similarly-the-paper-codeagent-first-proposed-an-agent-framework-for-repo---level-code-generation.-nevertheless-it-merely-adds-tools-to-the-llm-and-lacks-a-method-for-the-llm-to-comprehensively-understand-the-code-repository."><span class="nav-number">3.3.</span> <span class="nav-text">Take
repo - level code generation as an example. Many papers have proposed
agent - based methods. For instance, an early study by Peking
University, &quot;Self - Collaboration Code Generation via ChatGPT&quot;, based on
software development theory, sets different prompts for the same LLM,
enabling it to play three roles: analyst, coder, and tester. However, in
the analyst role, there is no dedicated method to help the LLM
understand the code repository. Similarly, the paper &quot;CodeAgent&quot; first
proposed an agent framework for repo - level code generation.
Nevertheless, it merely adds tools to the LLM and lacks a method for the
LLM to comprehensively understand the code repository.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#currently-a-small-number-of-studies-attempt-to-use-graphs-to-solve-this-problem.-since-the-core-of-understanding-a-code-repository-lies-in-grasping-the-complex-relationships-among-its-various-codes-and-files-and-graph-structures-can-effectively-model-these-relationships.-for-example-code-graph-models-cgm-published-in-june-this-year-and-the-reference-paper-repograph-both-construct-the-code-repository-as-a-graph-structure-and-then-feed-it-to-the-llm-for-processing.-essentially-the-edges-in-the-graph-make-the-relationships-between-files-and-codes-more-prominent.-in-contrast-if-the-code-repository-is-simply-flattened-and-directly-input-to-the-llm-when-the-repository-is-small-the-model-may-still-capture-some-relationships.-but-as-the-repository-size-increases-the-model-becomes-less-effective."><span class="nav-number">3.4.</span> <span class="nav-text">Currently,
a small number of studies attempt to use graphs to solve this problem.
Since the core of understanding a code repository lies in grasping the
complex relationships among its various codes and files, and graph
structures can effectively model these relationships. For example, &quot;Code
Graph Models (CGM)&quot; published in June this year and the reference paper
&quot;RepoGraph&quot; both construct the code repository as a graph structure and
then feed it to the LLM for processing. Essentially, the edges in the
graph make the relationships between files and codes more prominent. In
contrast, if the code repository is simply flattened and directly input
to the LLM, when the repository is small, the model may still capture
some relationships. But as the repository size increases, the model
becomes less effective.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#since-the-result-of-using-graphs-to-represent-the-code-repository-is-considered-could-introducing-graph-neural-networks-gnns-bring-better-results-because-gnns-have-inherent-advantages-in-processing-graph---structured-data.-currently-most-studies-only-provide-graph-data-to-transformers-which-requires-additional-processing-of-the-graph.-for-example-each-node-is-first-encoded-into-text-embeddings-then-projected-into-the-llms-embedding-space-and-converted-into-tokens-in-the-llm-to-be-processed-together-with-normal-text-input."><span class="nav-number">3.5.</span> <span class="nav-text">Since
the result of using graphs to represent the code repository is
considered, could introducing Graph Neural Networks (GNNs) bring better
results? Because GNNs have inherent advantages in processing graph -
structured data. Currently, most studies only provide graph data to
Transformers, which requires additional processing of the graph. For
example, each node is first encoded into text embeddings, then projected
into the LLM&#39;s embedding space, and converted into tokens in the LLM to
be processed together with normal text input.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#in-addition-this-graph---based-code-repository-understanding-method-has-the-potential-to-be-combined-with-various-agent---based-methods.-deeper-understanding-of-the-code-repository-can-reduce-errors-when-agents-perform-actions-and-decrease-error-accumulation.-at-the-same-time-the-effective-interaction-between-agents-and-the-code-repository-also-helps-to-further-improve-the-overall-understanding-of-the-code-repository.-moreover-these-two-methods-do-not-conflict-in-principle.-therefore-they-not-only-have-the-value-of-combination-but-also-the-feasibility-in-practice-which-is-worthy-of-in---depth-exploration."><span class="nav-number">3.6.</span> <span class="nav-text">In
addition, this graph - based code repository understanding method has
the potential to be combined with various agent - based methods. Deeper
understanding of the code repository can reduce errors when agents
perform actions and decrease error accumulation. At the same time, the
effective interaction between agents and the code repository also helps
to further improve the overall understanding of the code repository.
Moreover, these two methods do not conflict in principle. Therefore,
they not only have the value of combination but also the feasibility in
practice, which is worthy of in - depth exploration.</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bluemouse</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">256</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bluemouse</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
