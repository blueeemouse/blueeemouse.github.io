<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blueeemouse.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="bluemouse&#39;s blog">
<meta property="og:url" content="https://blueeemouse.github.io/index.html">
<meta property="og:site_name" content="bluemouse&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="bluemouse">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blueeemouse.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>bluemouse's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bluemouse's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueeemouse.github.io/2025/05/04/%E6%8D%A3%E9%BC%93blog/%E5%9F%BA%E4%BA%8Ewindows11%E7%9A%84blog%E6%90%AD%E5%BB%BA---hexo+github%20pages/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/04/%E6%8D%A3%E9%BC%93blog/%E5%9F%BA%E4%BA%8Ewindows11%E7%9A%84blog%E6%90%AD%E5%BB%BA---hexo+github%20pages/" class="post-title-link" itemprop="url">基于windows11的blog搭建---hexo+github pages</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-05-04 16:42:00 / Modified: 16:42:35" itemprop="dateCreated datePublished" datetime="2025-05-04T16:42:00+08:00">2025-05-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8D%A3%E9%BC%93blog/" itemprop="url" rel="index"><span itemprop="name">捣鼓blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="参考了很多网上的博客现在勉强是搭建出一个雏形凑合能用但显然还有很多地方有待优化只能慢慢来在使用中改进了">参考了很多网上的博客，现在勉强是搭建出一个雏形，凑合能用。但显然还有很多地方有待优化，只能慢慢来，在使用中改进了</h1>
<h1 id="hexo安装参考了比较多这个博客">1.hexo安装（参考了比较多<a
target="_blank" rel="noopener" href="https://www.6young.site/blog/de56ed25.html">这个博客</a>）</h1>
<h2
id="在这里主要做的是一些环境的配置">在这里主要做的是一些环境的配置</h2>
<h2 id="安装node.js">1.1.安装Node.js</h2>
<h3
id="其实直接去到它的官网就可以官网有教下载我是windows11然后是用命令行安装的也就是下面这几行命令">其实直接去到它的<a
target="_blank" rel="noopener" href="https://nodejs.org/en/download">官网</a>就可以，官网有教下载。我是windows11，然后是用命令行安装的，也就是下面这几行命令</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Download and install fnm:</span></span><br><span class="line">winget install Schniz.fnm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Download and install Node.js:</span></span><br><span class="line">fnm install 22</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Verify the Node.js version:</span></span><br><span class="line">node -v # Should print &quot;v22.13.1&quot;.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Verify npm version:</span></span><br><span class="line">npm -v # Should print &quot;10.9.2&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3
id="但有个问题就是如果是一次性把上面四个命令都执行完可能是没问题的如果把当前终端关掉再开一个然后试一下验证node.js和npm版本可能就会报错">但有个问题，就是如果是一次性把上面四个命令都执行完，可能是没问题的；如果把当前终端关掉，再开一个，然后试一下验证Node.js和npm版本，可能就会报错</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) PS C:\Users\user\Desktop&gt; fnm use 22 error: We can&#x27;t find the necessary environment variables to replace the Node version. You should setup your shell profile to evaluate `fnm env`, see [https://github.com/Schniz/fnm#shell-setup](https://github.com/Schniz/fnm#shell-setup) on how to do this Check out our documentation for more information: [https://fnm.vercel.app](https://fnm.vercel.app/)</span><br></pre></td></tr></table></figure>
<h3
id="这个问题主要是因为fnm环境没配置好根据fnm的github仓库安装完还得进行相应的配置才能正常使用fnm主要是要把一行代码写到终端的profile里windows的话就是要在power-shell的配置文件里写上fnm-env---use-on-cd---shell-powershell-out-string-invoke-expression它的作用是在每次打开-powershell-时加载-fnm-环境并在进入项目目录时自动切换到合适的-node.js-版本如果有-.node-version-或-.nvmrc-文件-至于打开这个配置文件可以这样notepad-profile方法应该是很多的可以搜到也可以问ai-加上之后就没问题关掉终端再重新开验证版本也不会报错了">这个问题主要是因为fnm环境没配置好。根据<a
target="_blank" rel="noopener" href="https://github.com/Schniz/fnm">fnm的github仓库</a>，安装完还得进行相应的配置才能正常使用fnm。主要是要把一行代码写到终端的profile里。windows的话，就是要在power
shell的配置文件里写上<code>fnm env --use-on-cd --shell powershell | Out-String | Invoke-Expression</code>。（它的作用是，在每次打开
PowerShell
时加载 <code>fnm</code> 环境，并在进入项目目录时自动切换到合适的 Node.js
版本（如果有 <code>.node-version</code> 或 <code>.nvmrc</code> 文件））<br>至于打开这个配置文件，可以这样：<code>notepad $PROFILE</code>（方法应该是很多的，可以搜到，也可以问AI）<br>加上之后就没问题，关掉终端再重新开，验证版本也不会报错了</h3>
<h2 id="安装git">1.2.安装git</h2>
<h3
id="这个教程就更多了随便搜一下应该就能搜到了">这个教程就更多了，随便搜一下应该就能搜到了</h3>
<h2 id="安装hexo">1.3.安装hexo</h2>
<h3 id="在power-shell里运行一下这三行命令就行">在power
shell里运行一下这三行命令就行：</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置npm镜像源</span></span><br><span class="line">npm config set registry https://registry.npmmirror.com</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装hexo命令行工具</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证hexo安装</span></span><br><span class="line">hexo -v</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果正确输出版本号，就说明安装成功</span></span><br></pre></td></tr></table></figure>
<h1 id="初步构建博客">2.初步构建博客</h1>
<h2
id="在这里我们最后能看到一个本地版的博客有一些初步成效">在这里，我们最后能看到一个”本地版“的博客，有一些初步成效</h2>
<h2
id="创建一个文件夹注意一定要是空的别往里面放东西否则init时会报错用来存放博客的各种文件然后在powershell中切到这个文件夹下或者直接在那个文件夹下打开power-shell依次运行如下命令">2.1.创建一个文件夹（注意，一定要是空的，别往里面放东西，否则init时会报错），用来存放博客的各种文件。然后，在powershell中切到这个文件夹下（或者直接在那个文件夹下打开power
shell），依次运行如下命令：</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init # 初始化博客  </span><br><span class="line">hexo generate # 申城网站信息  </span><br><span class="line">hexo server # 开始网站服务</span><br></pre></td></tr></table></figure>
<h2
id="正常的话init后原来空的那个文件夹里就会多出一些文件夹和文件比如sourcesthemes等最后hexo-server执行完后会有类似这样的输出">正常的话，init后，原来空的那个文件夹里就会多出一些文件夹和文件，比如sources，themes等；最后hexo
server执行完后，会有类似这样的输出：</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/username/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<h2
id="此时按住ctrl再左键点击这个链接就能跳转到博客的页面按道理来说就会看到一个hello-world的文档可以参考一下上面提到的那个博客它里面讲到博客构建要进行本地测试的时候有放一张图片是那个界面就没错了">此时按住ctrl再左键点击这个链接，就能跳转到博客的页面。按道理来说，就会看到一个hello
world的文档。可以参考一下<a
target="_blank" rel="noopener" href="https://www.6young.site/blog/de56ed25.html">上面提到的那个博客</a>，它里面讲到博客构建，要进行本地测试的时候，有放一张图片，是那个界面就没错了</h2>
<h1 id="部署到github-pages">3.部署到gitHub pages</h1>
<h2
id="上面虽然看到了一个页面说明博客框架搭建成功但它的网址是local-host并不是一般的网页链接我们最终的目的是希望能通过正常的网页链接访问到博客而github-pages就是一个可以借用的东西-它大概的作用是给我们提供一个免费的域名可以理解为一个网址而我们只要把博客的内容和配置文件部署或者说放到github就可以实现用它给的那个看起来正常的网址访问到我们的博客了">上面虽然看到了一个页面，说明博客框架搭建成功，但它的”网址“是local
host，并不是一般的网页链接。我们最终的目的是希望能通过正常的网页链接访问到博客。而github
pages就是一个可以借用的东西。
它大概的作用是，给我们提供一个免费的域名（可以理解为一个网址）。而我们只要把博客的内容和配置文件部署，或者说”放“到github，就可以实现用它给的那个”看起来正常的网址“访问到我们的博客了</h2>
<h2 id="准备相应github仓库">3.1.准备相应github仓库</h2>
<h3
id="注册一个github账户然后创建一个仓库并且这个仓库的名字要和你的github用户名保持一致也就是说这是一个特殊的github仓库这一步也比较简单很多教程可以查但需要注意创建的这个仓库的权限应该置为public否则是private的话还要进行部署就需要付费了那就有点失去我们本来用github-pages的意义了">注册一个github账户，然后创建一个仓库，并且这个仓库的名字要和你的github用户名保持一致（也就是说，这是一个特殊的github仓库）（这一步也比较简单，很多教程可以查。但需要注意，创建的这个仓库的权限应该置为public，否则，是private的话，还要进行部署，就需要付费了，那就有点失去我们本来用github
pages的意义了）</h3>
<h2 id="修改blog文件夹里的配置文件">3.2.修改blog文件夹里的配置文件</h2>
<h3
id="注意到上面第二步初步构建博客中那个存放博客相关文件的文件夹里会多出一些初始化的文件和文件夹其中有一个_config.yml文件就是hexo的配置文件打开它在最末尾加上如下内容">注意到上面第二步：初步构建博客中，那个存放博客相关文件的文件夹里，会多出一些初始化的文件和文件夹。其中有一个_config.yml文件，就是hexo的配置文件。打开它，在最末尾加上如下内容：</h3>
<figure class="highlight java"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"></span><br><span class="line">  type: git</span><br><span class="line"></span><br><span class="line">  repository: https:<span class="comment">//github.com/username/username.git  # 你的仓库地址</span></span><br><span class="line"></span><br><span class="line">  branch: gh-pages</span><br></pre></td></tr></table></figure>
<h3
id="需要修改的就是repository对应的仓库地址它就是你刚刚创建的那个仓库的地址以及branch它控制的是部署的时候我们把文件放到仓库的哪个分支如果是像这里的gh-pages那么到时候就是发布到gh-pages分支这个分支一开始是没有的部署的时候会自动创建但这样会导致github会认为这是一个项目仓库而不是一个特殊的仓库最终我们得到的一个网址的格式就是httpsusername.github.iousername而不是更为常见的username.github.io结尾是io在记忆上显然是后者更为简单易记不过使用上倒也大差不差吧如果是main分支则得到的网址就是io结尾的">需要修改的就是repository对应的仓库地址（它就是你刚刚创建的那个仓库的地址），以及branch。它控制的是，部署的时候，我们把文件放到仓库的哪个分支。如果是像这里的gh-pages，那么到时候就是发布到gh-pages分支（这个分支一开始是没有的，部署的时候会自动创建），但这样会导致，github会认为这是一个项目仓库，而不是一个”特殊“的仓库，最终我们得到的一个网址的格式就是https://username.github.io/username/，而不是更为常见的username.github.io（结尾是io），在记忆上显然是后者更为简单、易记。不过使用上倒也大差不差吧。如果是main分支，则得到的网址就是io结尾的</h3>
<h2 id="安装部署用的插件">3.3.安装部署用的插件</h2>
<h3
id="需要安装一下这个插件hexo-deployer-git-插件只需在power-shell中运行如下命令npm-install-hexo-deployer-git---save">需要安装一下这个插件：<code>hexo-deployer-git</code> 插件。只需在power
shell中运行如下命令<code>npm install hexo-deployer-git --save</code></h3>
<h2 id="公私钥认证">3.4.公私钥认证</h2>
<h3
id="在部署之前应该先生成一对公私钥然后把公钥放到github的账号上以进行认证从而可以往github仓库上传东西这个也比较简单只要把这一串要求给ai它给出的步骤基本就是可以完全照着执行的">在部署之前，应该先生成一对公私钥，然后把公钥放到github的账号上，以进行认证，从而可以往github仓库上传东西。这个也比较简单，只要把这一串要求给AI，它给出的步骤基本就是可以完全照着执行的</h3>
<h2 id="部署">3.5.部署</h2>
<h3 id="依次在power-shell中执行如下三行命令即可">依次在power
shell中执行如下三行命令即可：</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean # 清除缓存  </span><br><span class="line">hexo generate # 生成网站  </span><br><span class="line">hexo deploy # 部署至远程网络</span><br></pre></td></tr></table></figure>
<h3
id="至此部署就应该完成了如果你是传到main分支那么直接搜username.github.io应该就能搜到但可能需要登上一会几分钟乃至十分钟左右如果是上传到其它分支比如gh-pages则进到那个github仓库点击上面的settings按键然后在code-and-automation栏中点击pages应该能看到your-site-is-live-at-httpsxxx网址点击这个网址或者旁边的visit-site都可以跳转到网页正常应该就能看到博客内容了">至此，部署就应该完成了。如果你是传到main分支，那么直接搜username.github.io应该就能搜到（但可能需要登上一会，几分钟乃至十分钟左右）。如果是上传到其它分支，比如gh-pages，则进到那个github仓库，点击上面的Settings按键，然后在Code
and automation栏中点击Pages，应该能看到Your site is live
at https://xxx网址，点击这个网址，或者旁边的Visit
site都可以跳转到网页，正常应该就能看到博客内容了</h3>
<h3
id="之后如果还做了什么改动一般就还是运行上面的三个命令即可">之后如果还做了什么改动，一般就还是运行上面的三个命令即可</h3>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueeemouse.github.io/2025/05/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap2.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E9%93%BE%E8%A1%A8&%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97&kmp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap2.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E9%93%BE%E8%A1%A8&%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97&kmp/" class="post-title-link" itemprop="url">chap2.第一讲 链表&栈与队列&kmp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-05-04 16:41:00 / Modified: 16:41:23" itemprop="dateCreated datePublished" datetime="2025-05-04T16:41:00+08:00">2025-05-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algo/" itemprop="url" rel="index"><span itemprop="name">algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="链表">1.链表</h1>
<h2
id="简介这里主要讲的是用数组来模拟链表的操作而不是用结构体指针实现的链表具体会实现的有单链表常用于表示邻接表因而会用于图和树结构的表示和双链表常用于优化某些问题之所以在算法题里用数组来模拟主要是如果用结构体指针来构建链表的话每次增加一个节点都需要一个new操作这个操作是比较耗时的而算法题里又经常有比较多的操作这样的话可能光这些涉及到的new操作就超时了所以不太行故转向用数组模拟的静态链表">1.1.简介：这里主要讲的是用数组来模拟链表的操作，而不是用结构体＋指针实现的链表。具体会实现的有单链表（常用于表示邻接表，因而会用于图和树结构的表示）和双链表（常用于优化某些问题）（之所以在算法题里用数组来模拟，主要是如果用结构体+指针来构建链表的话，每次增加一个节点都需要一个new操作，这个操作是比较耗时的，而算法题里又经常有比较多的操作，这样的话可能光这些涉及到的new操作就超时了，所以不太行，故转向用数组模拟的静态链表</h2>
<h2 id="单链表">1.2.单链表</h2>
<h3
id="其实好像也没太多好说的主要的操作有初始化插入删除节点核心思路就是说每个节点都有一个当前节点的值以及它所指向的下一个节点的位置然后还需要维护一个当前的尾节点位置那么比如说我们要插入一个节点在第k个节点后面插入假设这个操作是合法的那么其实就把这个新节点的next置为第k个节点的next再把第k个节点的next置为这个新节点的位置并且更新尾节点位置即可删除也是类似的思路例如我们要删除第k个节点后面的那个节点依然假设这个操作合法则只需要让第k个节点的next置为第k个节点的next的next即可相当于说跳过了原来第k个节点的next节点至于说这里可能造成的一些空间上的浪费在算法题里是不怎么在意的工程上是需要注意的但是工程上也未必就用数组来模拟链表了更多还是用结构体指针实现了">其实好像也没太多好说的。。主要的操作有初始化，插入、删除节点。核心思路就是说，每个节点都有一个当前节点的值，以及它所指向的下一个节点的位置，然后还需要维护一个当前的尾节点位置。那么，比如说我们要插入一个节点，在第k个节点后面插入（假设这个操作是合法的），那么其实就把这个新节点的next置为第k个节点的next，再把第k个节点的next置为这个新节点的位置，并且更新尾节点位置即可；删除也是类似的思路，例如我们要删除第k个节点后面的那个节点（依然假设这个操作合法），则只需要让第k个节点的next置为第k个节点的next的next即可（相当于说跳过了原来第k个节点的next节点）（至于说这里可能造成的一些空间上的浪费，在算法题里是不怎么在意的；工程上是需要注意的，但是工程上也未必就用数组来模拟链表了，更多还是用结构体＋指针实现了）</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该题为AcWing模板题，摘录题目与代码仅为学习用</span></span><br><span class="line">实现一个单链表，链表初始为空，支持三种操作：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 向链表头插入一个数；</span><br><span class="line"><span class="number">2.</span> 删除第 k 个插入的数后面的一个数；</span><br><span class="line"><span class="number">3.</span> 在第 k 个插入的数后插入一个数。</span><br><span class="line"></span><br><span class="line">现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</span><br><span class="line"></span><br><span class="line">**注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 <span class="number">1</span> 个插入的数，第 <span class="number">2</span> 个插入的数，…第 n 个插入的数。</span><br><span class="line"></span><br><span class="line">#### 输入格式</span><br><span class="line"></span><br><span class="line">第一行包含整数 M，表示操作次数。</span><br><span class="line"></span><br><span class="line">接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> `H x`，表示向链表头插入一个数 x。</span><br><span class="line"><span class="number">2.</span> `D k`，表示删除第 k 个插入的数后面的数（当 k 为 <span class="number">0</span> 时，表示删除头结点）。</span><br><span class="line"><span class="number">3.</span> `I k x`，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 <span class="number">0</span>）。</span><br><span class="line"></span><br><span class="line">#### 输出格式</span><br><span class="line"></span><br><span class="line">共一行，将整个链表从头到尾输出。</span><br><span class="line"></span><br><span class="line">#### 数据范围</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>≤M≤<span class="number">100000</span></span><br><span class="line">所有操作保证合法。</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有个小细节需要注意，存放下一个节点的位置的数组，不能命名为next</span></span><br><span class="line"><span class="comment">// （至少如果using namespace std了的话，就不能，因为std命名空间里是已经有一个叫</span></span><br><span class="line"><span class="comment">// next的东西了，这样就重名了，会ambiguous，然后报错</span></span><br><span class="line"><span class="type">int</span> val[M], ne[M], head, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>, idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是说，头节点它不是一个虚的节点，而是实在的节点，即第一个节点（而双链表里的头尾节点</span></span><br><span class="line"><span class="comment">// 则可以认为是一个虚的节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在del函数中，k是比较特殊的，因为它代表删除头节点，所以需要单独处理</span></span><br><span class="line"><span class="comment">// 如果k &gt; 1，则就是正常的删除第k个数后面的那个数（第几个数这种说法里，这个“几”是不可以为0的，这也是为什么k==0时需要单独处理）</span></span><br><span class="line"><span class="comment">// 同时，我们也不需要担心此时第k个数就是最后一个数这种情况（此时是非法的，最后一个数后面没有数了，但题目保证了操作都是合法的）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) head = ne[head];    <span class="comment">// 删除头节点，不是说就把整个链表给删掉了，就是字面意思的删掉第一个节点，所以head往后移动一下即可</span></span><br><span class="line">    <span class="keyword">else</span> ne[k - <span class="number">1</span>] = ne[ne[k - <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个操作倒也比较简单，在第k个插入的数后面插入一个数，且保证了k是大于0的，所以就正常来即可</span></span><br><span class="line"><span class="comment">// 需要注意的可能就是索引问题，第k个插入的数，它对应的索引是k - 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val[idx] = x;</span><br><span class="line">    ne[idx] = ne[k - <span class="number">1</span>];</span><br><span class="line">    ne[k - <span class="number">1</span>] = idx;</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化别忘了</span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="type">char</span> operation;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; operation;</span><br><span class="line">        <span class="keyword">if</span> (operation == <span class="string">&#x27;H&#x27;</span>)   <span class="comment">// 加到头节点后面的操作是比较简单的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">del</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k, x;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; val[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双链表">1.3.双链表</h2>
<h3
id="基本思路是类似的只不过因为双链表中每个节点都有左右两个指针所以操作上是加倍了的">基本思路是类似的，只不过因为双链表中，每个节点都有左右两个指针，所以操作上是加倍了的</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">实现一个双链表，双链表初始为空，支持 <span class="number">5</span> 种操作：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 在最左侧插入一个数；</span><br><span class="line"><span class="number">2.</span> 在最右侧插入一个数；</span><br><span class="line"><span class="number">3.</span> 将第 k 个插入的数删除；</span><br><span class="line"><span class="number">4.</span> 在第 k 个插入的数左侧插入一个数；</span><br><span class="line"><span class="number">5.</span> 在第 k 个插入的数右侧插入一个数</span><br><span class="line"></span><br><span class="line">现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。</span><br><span class="line"></span><br><span class="line">**注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 <span class="number">1</span> 个插入的数，第 <span class="number">2</span> 个插入的数，…第 n 个插入的数。</span><br><span class="line"></span><br><span class="line">#### 输入格式</span><br><span class="line"></span><br><span class="line">第一行包含整数 M，表示操作次数。</span><br><span class="line"></span><br><span class="line">接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> `L x`，表示在链表的最左端插入数 x。</span><br><span class="line"><span class="number">2.</span> `R x`，表示在链表的最右端插入数 x。</span><br><span class="line"><span class="number">3.</span> `D k`，表示将第 k 个插入的数删除。</span><br><span class="line"><span class="number">4.</span> `IL k x`，表示在第 k 个插入的数左侧插入一个数。</span><br><span class="line"><span class="number">5.</span> `IR k x`，表示在第 k 个插入的数右侧插入一个数。</span><br><span class="line"></span><br><span class="line">#### 输出格式</span><br><span class="line"></span><br><span class="line">共一行，将整个链表从左到右输出。</span><br><span class="line"></span><br><span class="line">#### 数据范围</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>≤M≤<span class="number">100000</span> </span><br><span class="line">所有操作保证合法。</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样，这里也需要注意，用了命名空间std之后，就不能把左右指针的数组命名为left和right，</span></span><br><span class="line"><span class="comment">// 和上面一样，与现有的东西重名了，会引起歧义而报错</span></span><br><span class="line"><span class="type">int</span> val[M], l[M], r[M], head, tail, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里初始化的时候，head用0，tail用1，并没有像单链表里用-1来初始化。但这无关紧要。数组里的idx就类似于一个地址的作用</span></span><br><span class="line">    <span class="comment">// 另外，初始化的时候注意把左右邻接关系也初始化了</span></span><br><span class="line">    head = <span class="number">0</span>, tail = <span class="number">1</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">    l[tail] = head;</span><br><span class="line">    r[head] = tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里的逻辑关系本身是比较简单的，就是下面的语句顺序需要看清楚，不能随便换</span></span><br><span class="line">    val[idx] = x;</span><br><span class="line">    l[idx] = head;</span><br><span class="line">    r[idx] = r[head];</span><br><span class="line">    l[r[head]] = idx;</span><br><span class="line">    r[head] = idx;</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_tail</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    val[idx] = x;</span><br><span class="line">    r[idx] = tail;</span><br><span class="line">    l[idx] = l[tail];</span><br><span class="line">    r[l[tail]] = idx;</span><br><span class="line">    l[tail] = idx;</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意，为了方便下面的main函数，这里假设输入的k是从1开始的，而我们又要求索引是从2开始的（因为0和1分别是head和tail），</span></span><br><span class="line">    <span class="comment">// 所以k + 1的索引才代表第k个数</span></span><br><span class="line">    l[r[k + <span class="number">1</span>]] = l[k + <span class="number">1</span>];</span><br><span class="line">    r[l[k + <span class="number">1</span>]] = r[k + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_l</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 同样的，注意第k个数的索引是k + 1</span></span><br><span class="line">    val[idx] = x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先处理新插入的这个节点的邻居关系</span></span><br><span class="line">    l[idx] = l[k + <span class="number">1</span>];</span><br><span class="line">    r[idx] = k + <span class="number">1</span>;     <span class="comment">// 或者用r[idx] = r[l[k + 1]]; 也行，道理上是一样的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再处理插入新节点之后受影响的节点的邻居关系</span></span><br><span class="line">    r[l[k + <span class="number">1</span>]] = idx;</span><br><span class="line">    l[k + <span class="number">1</span>] = idx;</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_r</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val[idx] = x;</span><br><span class="line">    <span class="comment">// 下面先处理一下新插入的这个节点的邻居关系</span></span><br><span class="line">    l[idx] = k + <span class="number">1</span>;</span><br><span class="line">    r[idx] = r[k + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 然后处理一下原来的节点中受到影响的哪那两个节点（注意这两句的顺序！！）</span></span><br><span class="line">    l[r[k + <span class="number">1</span>]] = idx;   <span class="comment">// 处理一下第k个插入的数的原来的右邻居改变的关系（它的左邻居改变了）</span></span><br><span class="line">    r[k + <span class="number">1</span>] = idx;     <span class="comment">// 处理一下第k个插入的数的改变的关系（它只有右邻居改变了）</span></span><br><span class="line">    idx ++;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    string operation;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 下面所有的k，都是直接传到函数里的，也就是都是从1开始的。因此转换到索引的逻辑需要在各个函数里实现</span></span><br><span class="line">        cin &gt;&gt; operation;</span><br><span class="line">        <span class="keyword">if</span> (operation == <span class="string">&quot;L&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="string">&quot;R&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert_tail</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">del</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="string">&quot;IL&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k, x;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert_l</span>(k, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k, x;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert_r</span>(k, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// idx为1代表tail节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = r[head]; i != <span class="number">1</span>; i = r[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; val[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栈与队列">2.栈与队列</h1>
<h2
id="简介栈的核心思想就是先进后出队列则是先进先出栈就注意维护一下栈顶位置而队列则需要注意维护队头和队尾位置剩下的增加弹出的操作其实也就比较水到渠成了然后这里主要会讲的就是用数组模拟一般的栈和队列以及单调栈应用场景比较少看模板题吧和单调队列一个常见的模板题就是找出滑动窗口里的最值">2.1.简介：栈的核心思想就是先进后出，队列则是先进先出。栈就注意维护一下栈顶位置，而队列则需要注意维护队头和队尾位置，剩下的增加、弹出的操作其实也就比较水到渠成了。然后这里主要会讲的就是用数组模拟一般的栈和队列，以及单调栈（应用场景比较少，看模板题吧）和单调队列（一个常见的模板题就是找出滑动窗口里的最值）。</h2>
<p>其实关于单调栈，可能更重要的是它背后的思考过程：先想一个暴力的做法，然后关注是否有某些性质可以利用，从而可以优化代码
## 2.2.代码模板及模板题 ###
数组模拟栈（这个真的很简单，就把握住先进后出的原则即可）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">实现一个栈，栈初始为空，支持四种操作：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> `push x` – 向栈顶插入一个数 x；</span><br><span class="line"><span class="number">2.</span> `pop` – 从栈顶弹出一个数；</span><br><span class="line"><span class="number">3.</span> `empty` – 判断栈是否为空；</span><br><span class="line"><span class="number">4.</span> `query` – 查询栈顶元素。</span><br><span class="line"></span><br><span class="line">现在要对栈进行 M 个操作，其中的每个操作 <span class="number">3</span> 和操作 <span class="number">4</span> 都要输出相应的结果。</span><br><span class="line"></span><br><span class="line">#### 输入格式</span><br><span class="line"></span><br><span class="line">第一行包含整数 M，表示操作次数。</span><br><span class="line"></span><br><span class="line">接下来 M 行，每行包含一个操作命令，操作命令为 `push x`，`pop`，`empty`，`query` 中的一种。</span><br><span class="line"></span><br><span class="line">#### 输出格式</span><br><span class="line"></span><br><span class="line">对于每个 `empty` 和 `query` 操作都要输出一个查询结果，每个结果占一行。</span><br><span class="line"></span><br><span class="line">其中，`empty` 操作的查询结果为 `YES` 或 `NO`，`query` 操作的查询结果为一个整数，表示栈顶元素的值。</span><br><span class="line"></span><br><span class="line">#### 数据范围</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>≤M≤<span class="number">100000</span>,  </span><br><span class="line"><span class="number">1</span>≤x≤<span class="number">10</span>^<span class="number">9</span>  </span><br><span class="line">所有操作保证合法，即不会在栈为空的情况下进行 `pop` 或 `query` 操作。</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> stack[M], top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top ++;</span><br><span class="line">    stack[top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 因为题目确保了query操作一定是合法的，也就是query的时候stack一定不为空，所以直接返回结果就好</span></span><br><span class="line">    <span class="keyword">return</span> stack[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    string op;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;query&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="built_in">query</span>();</span><br><span class="line">            cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### 数组模拟队列 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">实现一个队列，队列初始为空，支持四种操作：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> `push x` – 向队尾插入一个数 x；</span><br><span class="line"><span class="number">2.</span> `pop` – 从队头弹出一个数；</span><br><span class="line"><span class="number">3.</span> `empty` – 判断队列是否为空；</span><br><span class="line"><span class="number">4.</span> `query` – 查询队头元素。</span><br><span class="line"></span><br><span class="line">现在要对队列进行 M 个操作，其中的每个操作 <span class="number">3</span> 和操作 <span class="number">4</span> 都要输出相应的结果。</span><br><span class="line"></span><br><span class="line">#### 输入格式</span><br><span class="line"></span><br><span class="line">第一行包含整数 M，表示操作次数。</span><br><span class="line"></span><br><span class="line">接下来 M 行，每行包含一个操作命令，操作命令为 `push x`，`pop`，`empty`，`query` 中的一种。</span><br><span class="line"></span><br><span class="line">#### 输出格式</span><br><span class="line"></span><br><span class="line">对于每个 `empty` 和 `query` 操作都要输出一个查询结果，每个结果占一行。</span><br><span class="line"></span><br><span class="line">其中，`empty` 操作的查询结果为 `YES` 或 `NO`，`query` 操作的查询结果为一个整数，表示队头元素的值。</span><br><span class="line"></span><br><span class="line">#### 数据范围</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>≤M≤<span class="number">100000</span>,  </span><br><span class="line"><span class="number">1</span>≤x≤<span class="number">109</span>,  </span><br><span class="line">所有操作保证合法，即不会在队列为空的情况下进行 `pop` 或 `query` 操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hh, tt, q[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里队列头和队列尾如何表示，应该也是比较看个人习惯的。这里就考虑：hh指队列里的第一个元素，tt指队列里的最后一个元素，</span></span><br><span class="line"><span class="comment">// 它们都不是虚的，而是确有这个数的。此时，当队列里只有一个元素的时候，hh应该等于tt</span></span><br><span class="line"><span class="comment">// 也因此，如果队列为空，则应该有hh大于tt，这也影响了下面的empty函数的逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tt++;</span><br><span class="line">    q[tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hh++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hh &gt; tt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[hh];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 别忘了初始化</span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    string op;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> head_val = <span class="built_in">query</span>();</span><br><span class="line">            cout &lt;&lt; head_val &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; q[0];</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 单调栈 ####
以下面的模板提为例，讲解一下它的思路：我们是先找到一个暴力的做法，然后找到一些性质进行优化。暴力的做法，不难想到，我们会遍历数组里的每一个数，比如轮到第i个数，之后我们会从它的左边第一个开始找起：如果这个元素小于当前元素，则符合题意，直接输出；否则继续往左移动，直到找到某个小于当前元素的值（则输出），或者找完了也没有（说明左边的元素都大于等于当前元素，则输出-1）。实现的时候，需要用到二重for循环。时间复杂度应该是<span
class="math inline">\(O(n^{2})\)</span> ####
其中有一些元素其实是不需要遍历的。因为题目要求找到每个元素“左边”的第一个比它小的数，也就是说，假设我们遍历到第i个元素，它的左边有两个元素x和y，满足：x&gt;=y，且x在y的左边，则x一定不会是答案（因为，y在x的右边，更靠近当前元素，且y还不比x大，则如果y满足条件，肯定直接输出了；如果y不满足条件，x肯定也不满足条件）。这个性质就是我们要利用的：
#####
我们维护一个单调栈，从前往后遍历数组里的元素的时候，单调栈里存的就是当前元素左边的不断增长的一个序列。我们从栈顶开始往下找，如果有比当前元素小的，则输出；如果找遍了栈也没有，则说明当前元素左边没有比它小的元素，则我们清空栈，并把当前元素存进去（当前元素对于后面的所有元素来说，目前是最优的：因为它最靠右，离后面的元素最近，且它比前面的元素都要小，如果它是答案，左边的所有元素都轮不到；如果它不是答案，左边的所有元素更轮不到）
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">#### 输入格式</span><br><span class="line"></span><br><span class="line">第一行包含整数 N，表示数列长度。</span><br><span class="line"></span><br><span class="line">第二行包含 N 个整数，表示整数数列。</span><br><span class="line"></span><br><span class="line">#### 输出格式</span><br><span class="line"></span><br><span class="line">共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">#### 数据范围</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">10</span>^<span class="number">5</span>  </span><br><span class="line"><span class="number">1</span>≤数列中元素≤<span class="number">10</span>^<span class="number">9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我的做法</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> stk[N], idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scanf, printf真的比cin, cout快好多。。。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="comment">// cin &gt;&gt; x;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="comment">// 这里写的比较琐碎，但体现了一个思考过程吧</span></span><br><span class="line">        <span class="comment">// 首先，idx指示单调栈的元素个数，如果单调栈为空，则idx==0</span></span><br><span class="line">        <span class="comment">// 这里先看一下 1.单调栈不为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 情况1.1.当前元素直接比单调栈顶的元素要大（这是最简单的情况，此时直接输出单调栈顶的元素即可。但不要忘记把</span></span><br><span class="line">            <span class="comment">// 当前元素也存到单调栈里）</span></span><br><span class="line">            <span class="keyword">if</span> (x &gt; stk[idx])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; stk[idx] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk[idx]);</span><br><span class="line">                stk[++idx] = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况1.2.当前元素比单调栈顶的元素要小（这里就稍微复杂一点，也是单调栈的核心了）</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 我们需要遍历单调栈，从单调栈顶往底下遍历</span></span><br><span class="line">                <span class="keyword">while</span> (x &lt;= stk[idx] &amp;&amp; idx &gt; <span class="number">0</span>) idx--;</span><br><span class="line">                <span class="comment">// 如果遍历完了单调栈，还是没在栈里找到一个小于当前元素的，则说明当前元素是截至目前为止最小的，我们就把它存到</span></span><br><span class="line">                <span class="comment">// 单调栈里</span></span><br><span class="line">                <span class="keyword">if</span> (idx == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    stk[++idx] = x;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果我们在栈里找到了某个元素，比当前元素小，则输出它即可，同时也需要把当前元素存到单调栈里</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; stk[idx] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk[idx]);</span><br><span class="line">                    stk[++idx] = x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况2.如果单调栈为空，则直接输出-1即可（这种情况只可能在开头有，后面无论怎样，就算有某个元素把单调栈里的元素全挤出去</span></span><br><span class="line">        <span class="comment">// 了，它自己也会补充进来，单调栈不会为空</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="number">-1</span>);</span><br><span class="line">            stk[++idx] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ai生成的精简版代码，比我的简短很多，逻辑比较清晰吧</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当栈不为空且栈顶元素大于等于当前元素时，弹出栈顶元素</span></span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &amp;&amp; stk.<span class="built_in">top</span>() &gt;= x) stk.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; stk.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前元素压入栈中</span></span><br><span class="line">        stk.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # 3.kmp算法 ##
3.1.简介：这个是用来进行字符串匹配的，也就是用于在一个主字符串（文本）中快速查找某个子字符串（模式串）是否存在，或找出所有出现的位置<br>它的提出和单调栈/队列是类似的，也是先找出一个暴力的做法，然后在此基础上进行优化<br>暴力做法是把模式串从头开始移动，从第一个字符开始匹配，一直往下，如果出现不匹配的情况，则把模式串整体右移一位，继续开始逐字符匹配，直到模式串到达了原字符串的末尾为止。时间复杂度是<span
class="math inline">\(O(n*m)\)</span>（其中n为原字符串的长度，m为模式串的长度）；优化后则是线性复杂度，为<span
class="math inline">\(O(n+m)\)</span>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueeemouse.github.io/2025/05/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap2.%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%20trie%E6%A0%91&%E5%B9%B6%E6%9F%A5%E9%9B%86&%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap2.%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%20trie%E6%A0%91&%E5%B9%B6%E6%9F%A5%E9%9B%86&%E5%A0%86/" class="post-title-link" itemprop="url">chap2.第二讲 trie树&并查集&堆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-05-04 16:41:00 / Modified: 16:41:51" itemprop="dateCreated datePublished" datetime="2025-05-04T16:41:00+08:00">2025-05-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algo/" itemprop="url" rel="index"><span itemprop="name">algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="trie树">1.trie树</h1>
<h1 id="并查集">2.并查集</h1>
<h2 id="简介">2.1.简介：</h2>
<h3
id="并查集的两大作用是快速地将两个集合合并询问两个元素是否在同一个集合当中">并查集的两大作用是：快速地将两个集合合并；询问两个元素是否在同一个集合当中</h3>
<h3
id="这里其实我们可以思考一下为什么要用并查集来处理这两个问题换句话说我们可以看看朴素做法有什么不足的比如如果我们有一批元素它们各自都属于某个集合然后我们用一个数组来表示每个元素属于哪个集合假设有个belongn数组belongi-a就表示元素i属于集合a这样的话其实第二个问题是很好解决的o1复杂度即可搞定比较麻烦的是第一个问题即合并两个集合按照我们上面的记号假设是合并a和b两个集合则要么把a里的所有元素在belong数组里的值改成b要么是把b里的所有元素在belong数组里的值改成a即使我们挑的是两个集合里较少的那个也很耗费时间若记较少的那个集合的元素数量为m则时间复杂度为om">这里其实我们可以思考一下为什么要用并查集来处理这两个问题。换句话说，我们可以看看朴素做法有什么不足的。比如，如果我们有一批元素，它们各自都属于某个集合。然后我们用一个数组来表示每个元素属于哪个集合，假设有个belong[N]数组，belong[i]
= a就表示元素i属于集合a。这样的话，其实第二个问题是很好解决的，<span
class="math inline">\(O(1)\)</span>复杂度即可搞定。比较麻烦的是第一个问题，即合并两个集合。按照我们上面的记号，假设是合并a和b两个集合，则要么把a里的所有元素在belong数组里的值改成b，要么是把b里的所有元素在belong数组里的值改成a，即使我们挑的是两个集合里较少的那个，也很耗费时间（若记较少的那个集合的元素数量为M，则时间复杂度为<span
class="math inline">\(O(M)\)</span>）</h3>
<h3
id="因此有必要进行优化并查集就是用来快速解决上面两个问题的它可以以近乎o1的时间复杂度来解决上面两个问题注意这个近乎也算是一个小细节后面结合实现的代码就可以知道为什么">因此，有必要进行优化。并查集就是用来快速解决上面两个问题的，它可以以近乎<span
class="math inline">\(O(1)\)</span>的时间复杂度来解决上面两个问题（注意这个近乎，也算是一个小细节，后面结合实现的代码就可以知道为什么）</h3>
<h2 id="代码模板">2.2.代码模板</h2>
<h3
id="先讲一下原理此时我们对每个集合都用一棵树来表示树根的编号就是整个集合的编号每个节点都存储了它的父节点我们用一个数组来存储px表示节点x的父节点-并且我们约定只有根节点整个集合的节点或者说祖宗节点的父节点才等于自身即满足px-x其它节点都是不满足的这样我们就可以判断一个节点是不是树根了">先讲一下原理。此时我们对每个集合，都用一棵树来表示，树根的编号就是整个集合的编号。每个节点都存储了它的父节点，我们用一个数组来存储，p[x]表示节点x的父节点<br>并且，我们约定，只有根节点（整个集合的节点，或者说祖宗节点）的父节点才等于自身，即满足<code>p[x] == x</code>，其它节点都是不满足的。这样我们就可以判断一个节点是不是树根了</h3>
<h3
id="然后回顾我们的两个问题对于第一个问题合并两个集合只需要把其中一个集合的根节点当成另一个集合的子节点即可这样只需要修改一下一个集合的根节点的父节点即可o1的时间复杂度内即可完成">然后，回顾我们的两个问题，对于第一个问题，合并两个集合，只需要把其中一个集合的根节点当成另一个集合的子节点即可。这样只需要修改一下一个集合的根节点的父节点即可，<span
class="math inline">\(O(1)\)</span>的时间复杂度内即可完成</h3>
<h3
id="对于第二个问题我们的想法是找出这两个待查询的元素的祖宗节点判断一下是否相等即可而要找出一个节点的祖宗节点根据上面判断树根的方法只需while-px-x-x-px-但这样一看似乎解决第二个问题上并查集还不如朴素做法因为还需要一直往上遍历到根节点而这是和我们的树的高度成正相关的而假如一开始所有元素所属的集合都不同后续会进行各种合并操作那么树的高度就等于这个集合把其它集合合并过来的次数">对于第二个问题，我们的想法是，找出这两个待查询的元素的祖宗节点，判断一下是否相等即可。而要找出一个节点的祖宗节点，根据上面判断树根的方法，只需：<code>while (p[x] != x) x = p[x];</code><br>但这样一看，似乎解决第二个问题上，并查集还不如朴素做法。因为还需要一直往上遍历到根节点，而这是和我们的树的高度成正相关的（而假如一开始所有元素所属的集合都不同，后续会进行各种合并操作，那么树的高度就等于这个集合把其它集合合并过来的次数）</h3>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueeemouse.github.io/2025/05/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap1.%E7%AC%AC%E4%B8%89%E8%AE%B2%20%20%E5%8F%8C%E6%8C%87%E9%92%88&%E4%BD%8D%E8%BF%90%E7%AE%97&%E7%A6%BB%E6%95%A3%E5%8C%96&%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap1.%E7%AC%AC%E4%B8%89%E8%AE%B2%20%20%E5%8F%8C%E6%8C%87%E9%92%88&%E4%BD%8D%E8%BF%90%E7%AE%97&%E7%A6%BB%E6%95%A3%E5%8C%96&%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/" class="post-title-link" itemprop="url">chap1.第三讲 双指针&位运算&离散化&区间合并</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-05-04 16:40:00 / Modified: 16:40:51" itemprop="dateCreated datePublished" datetime="2025-05-04T16:40:00+08:00">2025-05-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algo/" itemprop="url" rel="index"><span itemprop="name">algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="双指针">1.双指针</h1>
<h2
id="简介这个其实更多是一种思想或者说思路它的主要作用是利用某种性质进行优化通常是把on2的算法优化成on这里的性质可以理解为某种单调性比如前面归并排序中有一步要把两个有序的数组合并为一个有序的数组其中就用到了双指针两个指针从两个数组的起点开始谁指向的元素更小那个元素就是当前最小的元素则放到合并后的大数组并且相应指针往后移动一位这里用到的单调性就是两个数组都是有序的当前指针后面的所有数都是大于等于当前指针指向的元素的所以每次只需要比较一下当前两个指针指向的元素谁更小不需要和后面的相比这里就剩下了时间复杂度所以最后两个指针都只需要遍历一遍数组故时间复杂度是on">1.1.简介：这个其实更多是一种思想，或者说思路。它的主要作用是利用某种性质，进行优化，通常是把<span
class="math inline">\(O(n^{2})\)</span>的算法优化成<span
class="math inline">\(O(n)\)</span>。这里的性质，可以理解为某种单调性。比如，前面归并排序中，有一步要把两个有序的数组合并为一个有序的数组，其中就用到了双指针：两个指针从两个数组的起点开始，谁指向的元素更小，那个元素就是当前最小的元素，则放到合并后的大数组，并且相应指针往后移动一位。这里用到的单调性就是，两个数组都是有序的，当前指针后面的所有数都是大于等于当前指针指向的元素的，所以每次只需要比较一下当前两个指针指向的元素谁更小，不需要和后面的相比——这里就剩下了时间复杂度。所以最后两个指针都只需要遍历一遍数组，故时间复杂度是<span
class="math inline">\(O(n)\)</span></h2>
<h2 id="代码模板">1.2.代码模板</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure>
<h3
id="来道具体例题输入第一行是n表示元素个数第二行是数组元素要求其中最长的不包含重复元素的连续区间的长度">来道具体例题：输入第一行是n，表示元素个数；第二行是数组元素，要求其中最长的不包含重复元素的<strong>连续</strong>区间的长度</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], record[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 此处i会遍历所有的数，它是区间的右指针，j是区间的左指针，它的含义是：以i为终点时，区间的起点最多</span></span><br><span class="line">    <span class="comment">// 可以往左到哪里</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        record[a[i]] ++;</span><br><span class="line">        <span class="keyword">while</span> (record[a[i]] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            record[a[j]] --;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="上面有几点需要注意一个是题目里的连续区间要求了连续所以需要用双指针另一个是题目的元素个数是介于1和1e5之间元素值是介于0和1e5之间所以我们中间检查区间里是否有重复元素的方法是创建一个record数组其第i个元素的值表示的是当前区间中值等于i的元素个数因为不能重复所以必须小于等于1大于1就重复了然而如果元素值的范围更大或者存的不是数而是字母乃至字符串之类的话还用数组就不太好了更一般的操作是用一个哈希表来快速查询后面会讲">上面有几点需要注意：一个是题目里的连续区间，要求了连续，所以需要用双指针；另一个是，题目的元素个数是介于1和1e5之间，元素值是介于0和1e5之间，所以我们中间检查区间里是否有重复元素的方法是，创建一个record数组，其第i个元素的值表示的是当前区间中，值等于i的元素个数；因为不能重复，所以必须小于等于1，大于1就重复了。然而，如果元素值的范围更大，或者存的不是数，而是字母、乃至字符串之类的话，还用数组就不太好了。更一般的操作是用一个哈希表来快速查询。后面会讲</h4>
<h1 id="位运算">2.位运算</h1>
<h2
id="简介这里主要介绍两种比较常见的一是求出一个十进制数的二进制表示中第k位是几二是lowbit它是要求出一个十进制数的二进制表示中从右往左第一次出现1的那个位置对应的数比如一个二进制数是1010100那么它的lowbit结果就是100这个东西在树状数组里会用到以及它也可以用来求出一个二进制数中的1的个数">2.1.简介：这里主要介绍两种比较常见的，一是求出一个十进制数的二进制表示中，第k位是几；二是lowbit，它是要求出一个十进制数的二进制表示中，从右往左，第一次出现1的那个位置对应的数（比如，一个二进制数是1010100，那么它的lowbit结果就是100）。这个东西在树状数组里会用到；以及它也可以用来求出一个二进制数中的1的个数</h2>
<h2 id="代码模板-1">2.2.代码模板</h2>
<h3 id="核心其实都是一行代码">核心其实都是一行代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure>
<h3
id="上面的第一行就是第一种操作首先这个表达式会先进行移位操作即n-k这个具体来说就是把n先转化成二进制数假设是10100然后把这个二进制数右移k位假设k是3那么右移3位之后得到的就是10前面会少3位可以补上0但从值的大小上来说就等于这个10_2-之后是1操作是按位与操作它会把两个操作数都转化成二进制数然后一位一位去看如果某一位上这两个数都是1那么得到的结果中这一位就是1否则是0举个例子1010和1000按位与得到1000所以到这里也就能明白为什么n-k-1可以判断出n的二进制表示下第k位数字是否为1了先把n右移k位则此时最低位的数字就是原来n的第k位数字1的二进制表示是只有最后一位为1前面的位均为0所以按位与的结果里前面必然都是0只有最后一位可能是1若最后一位是1就表明n的第k位数字确实为1这个判断方法返回的结果也刚好是1如果最后一位是0则表明n的第k位数字为0返回的结果也是0">上面的第一行就是第一种操作。首先，这个表达式会先进行移位操作，即n
&gt;&gt;
k。这个具体来说就是，把n先转化成二进制数，假设是10100；然后把这个二进制数右移k位。假设k是3，那么右移3位之后得到的就是10，前面会少3位，可以补上0，但从值的大小上来说，就等于这个<span
class="math inline">\((10)_{2}\)</span>
<br>之后是&amp;1操作，&amp;是按位与操作，它会把两个操作数都转化成二进制数，然后一位一位去看，如果某一位上，这两个数都是1，那么得到的结果中，这一位就是1，否则是0。举个例子，1010和1000按位与，得到1000。所以，到这里也就能明白为什么<code>n &gt;&gt; k &amp; 1</code>可以判断出n的二进制表示下，第k位数字是否为1了：先把n右移k位，则此时最低位的数字就是原来n的第k位数字；1的二进制表示是只有最后一位为1，前面的位均为0，所以按位与的结果里，前面必然都是0，只有最后一位可能是1。若最后一位是1，就表明n的第k位数字确实为1，这个判断方法返回的结果也刚好是1；如果最后一位是0，则表明n的第k位数字为0，返回的结果也是0</h3>
<h3
id="上面的第二行就是lowbit操作它就是自己与自己的相反数进行按位与因为cpp中负数的表示是用补码来表示的所以我们讨论一下一般情况假设n的二进制表示为101010000斜体的那个1就是最后的一个1那么因为补码就是取反加一所以先取反得到010101111斜体的那个0就对应刚才的1再加一得到010110000-不难发现取反加一之后还是在同一个位置出现了最后的1此时将原数与相反数进行按位与那么在最后的1之前显然各位都不同有0有1则得到的都是0在最后的1那一位相同都是1故得到1在最后的1之后全都是0故得到的全都是0所以最终按位与的结果就是000010000即只在最后的1那一位上为1其它位上全为0由此即得到所求">上面的第二行就是lowbit操作，它就是自己与自己的相反数进行按位与。因为cpp中，负数的表示是用补码来表示的，所以，我们讨论一下一般情况，假设n的二进制表示为1010……<strong><em>1</em></strong>0000……（斜体的那个1就是最后的一个1），那么因为补码就是取反加一，所以先取反得到0101……<strong><em>0</em></strong>1111……（斜体的那个0就对应刚才的1），再加一，得到0101……<strong><em>1</em></strong>0000……<br>不难发现，取反加一之后，还是在同一个位置，出现了最后的1。此时将原数与相反数进行按位与，那么在最后的1之前，显然各位都不同，有0有1，则得到的都是0；在最后的1那一位，相同，都是1，故得到1；在最后的1之后，全都是0，故得到的全都是0，所以最终按位与的结果就是0000……<strong><em>1</em></strong>0000……，即只在最后的1那一位上为1，其它位上全为0，由此即得到所求</h3>
<h3
id="一些额外的说明像这种按位运算操作计算机都是会把输入的数转化成二进制来做的毕竟它们的定义就是依靠二进制形式的而输出结果会转化为十进制再返回">一些额外的说明：像&amp;，|，^这种按位运算操作，计算机都是会把输入的数转化成二进制来做的（毕竟它们的定义就是依靠二进制形式的），而输出结果会转化为十进制再返回</h3>
<h3 id="附上一道模板题">附上一道模板题：</h3>
<h4
id="输入第一行为n表示有n个数之后一行里有n个数0leq-元素值-leq-109要判断这n个数的二进制表示中1的个数输出为一行每个答案之间间隔一个空格">输入第一行为n，表示有n个数，之后一行里有n个数（<span
class="math inline">\(0\leq 元素值 \leq
10^{9}\)</span>），要判断这n个数的二进制表示中1的个数，输出为一行，每个答案之间间隔一个空格</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个也就是lowbit操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_one_nums</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里就是求出一个数里的二进制表示中的1的个数的核心操作</span></span><br><span class="line">        <span class="comment">// 每次我们都用find_one_nums（也就是lowbit操作）找出当前这个数里最前面</span></span><br><span class="line">        <span class="comment">// 的那个1，再把它减掉，这样原来的数的二进制表示中就少了一个1了；如此一直</span></span><br><span class="line">        <span class="comment">// 循环减下去，当这个数减到0的时候，也就找出了所有的1</span></span><br><span class="line">        <span class="keyword">while</span> (x) </span><br><span class="line">        &#123;</span><br><span class="line">            x -= <span class="built_in">find_one_nums</span>(x);</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="离散化">3.离散化</h1>
<h2 id="简介">3.1.简介：</h2>
<h3
id="它的使用场景是一种数据比较稀疏的情况具体来说如果给定一些元素它们的下标范围可能非常的大比如在数轴上的话范围跨度为-109-sim-109此外我们假设如果一个下标没有显式地给出对应的元素则默认它对应的元素是0而它的元素值范围可能跨度并不大比如可能是-10000sim10000并且这些元素的个数也不多例如1sim10000这个过大的下标范围可能带来一些问题例如在上面提到的这个情况下如果我想多次查询每次查询就是要求出指定区间内的所有元素和那么这个查询的方式其实容易让人想到构造一个一维前缀和数组但问题在于这里过大的下标范围就要求我们先开一个特别大的数组以上面的情况为例应该是长度为21091太大了占太多内存而实际情况是这么大的一个数组里因为元素数并不多所以用到的也不多这就很浪费了所以离散化就是用来缓解这个问题的">它的使用场景是一种数据比较稀疏的情况。具体来说，如果给定一些元素，它们的下标范围可能非常的大（比如在数轴上的话，范围跨度为<span
class="math inline">\(-10^{9} \sim
10^{9}\)</span>。此外我们假设，如果一个下标没有显式地给出对应的元素，则默认它对应的元素是0），而它的元素值范围可能跨度并不大（比如可能是<span
class="math inline">\(-10000\sim10000\)</span>），并且这些元素的个数也不多（例如<span
class="math inline">\(1\sim10000\)</span>）。这个过大的下标范围可能带来一些问题。例如，在上面提到的这个情况下，如果我想多次查询，每次查询就是要求出指定区间内的所有元素和，那么这个查询的方式其实容易让人想到构造一个一维前缀和数组。但问题在于，这里过大的下标范围，就要求我们先开一个特别大的数组（以上面的情况为例，应该是长度为<span
class="math inline">\(2×10^{9}+1\)</span>，太大了，占太多内存。而实际情况是，这么大的一个数组里，因为元素数并不多，所以用到的也不多。这就很浪费了。所以离散化就是用来缓解这个问题的</h3>
<h3
id="对这些元素我们按照它们的下标从小到大排序依次对应重新映射举个例子如果一些元素如下1-22-300-40005000000我们给它们重新映射一下1对应122对应2300对应34000对应45000000对应5则完成离散化之后如果我们还是想解决上面提到的问题就可以通过离散化的映射避免开一个特别大的数组了">对这些元素，我们按照它们的下标从小到大排序，依次对应，重新映射。举个例子，如果一些元素如下：1，
22， 300，
4000，5000000；我们给它们重新映射一下，1对应1，22对应2，300对应3，4000对应4，5000000对应5，则完成离散化。之后，如果我们还是想解决上面提到的问题，就可以通过离散化的映射，避免开一个特别大的数组了：</h3>
<h4
id="首先明确我们的查询次数以及每次查询的左右区间端点把这些所有的端点按照从小到大的顺序排好并进行离散化的映射此时我们根据查询次数记为m以及每个查询用到两个端点可以知道一共涉及了2m个元素于是我们可以构造一个长度为2m的数组res里面从左到右分别是从小到大的端点对应的元素我们对它求一个一维前缀和数组这样就可以快速实现查询的功能了比如我们现在想查询原下标里-100000到2345678之间的所有元素之和那么我们先根据离散化的映射把-100000和2345678进行映射假设是2和7根据这个2和7对res的前缀和数组prefix_res由prefix_res7-prefix_res1即可得到结果其余查询是类似的">首先明确我们的查询次数，以及每次查询的左右区间端点；把这些所有的端点按照从小到大的顺序排好，并进行离散化的映射。此时我们根据查询次数（记为m）以及每个查询用到两个端点，可以知道，一共涉及了2m个元素。于是我们可以构造一个长度为2m的数组res，里面从左到右分别是从小到大的端点对应的元素。我们对它求一个一维前缀和数组。这样就可以快速实现查询的功能了。比如，我们现在想查询原下标里，-100000到2345678之间的所有元素之和。那么，我们先根据离散化的映射，把-100000和2345678进行映射，假设是2和7；根据这个2和7，对res的前缀和数组prefix_res，由prefix_res[7]-prefix_res[1]即可得到结果。其余查询是类似的</h4>
<h4 id="section"></h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueeemouse.github.io/2025/05/03/algo/leetcode%E9%9A%8F%E6%9C%BA%E5%88%B7/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2%EF%BC%88%E5%85%B3%E4%BA%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/03/algo/leetcode%E9%9A%8F%E6%9C%BA%E5%88%B7/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2%EF%BC%88%E5%85%B3%E4%BA%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-05-03 16:43:11 / Modified: 17:11:55" itemprop="dateCreated datePublished" datetime="2025-05-03T16:43:11+08:00">2025-05-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述原题链接">题目描述（<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=company&amp;envId=huawei&amp;favoriteSlug=huawei-thirty-days">原题链接</a>）</h1>
<h2
id="给定一个字符串-s-请你找出其中不含有重复字符的-最长-子串-的长度">给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</h2>
<h2 id="示例-1"><strong>示例 1:</strong></h2>
<h3
id="输入-s-abcabcbb-输出-3-解释-因为无重复字符的最长子串是-abc所以其长度为-3"><strong>输入:</strong>
s = "abcabcbb"<br><strong>输出:</strong> 3 <br><strong>解释:</strong>
因为无重复字符的最长子串是 <code>"abc"</code>，所以其长度为 3。</h3>
<h2 id="示例-2"><strong>示例 2:</strong></h2>
<h3
id="输入-s-bbbbb-输出-1-解释-因为无重复字符的最长子串是-b所以其长度为-1"><strong>输入:</strong>
s = "bbbbb"<br><strong>输出:</strong> 1<br><strong>解释:</strong>
因为无重复字符的最长子串是 <code>"b"</code>，所以其长度为 1。</h3>
<h2 id="示例-3"><strong>示例 3:</strong></h2>
<h3
id="输入-s-pwwkew-输出-3-解释-因为无重复字符的最长子串是-wke所以其长度为-3-请注意你的答案必须是-子串-的长度pwke-是一个_子序列_不是子串"><strong>输入:</strong>
s = "pwwkew"<br><strong>输出:</strong> 3<br><strong>解释:</strong>
因为无重复字符的最长子串是 <code>"wke"</code>，所以其长度为
3。<br>请注意，你的答案必须是 <strong>子串</strong>
的长度，<code>"pwke"</code> 是一个_子序列，_不是子串。</h3>
<h2 id="提示"><strong>提示：</strong></h2>
<h3 id="s.length-5-104">-
<code>0 &lt;= s.length &lt;= 5 * 104</code></h3>
<h3 id="s-由英文字母数字符号和空格组成">-
<code>s</code> 由英文字母、数字、符号和空格组成</h3>
<h1 id="思路">思路：</h1>
<h2
id="它只要求找出不含重复长度的最长字串的长度而已相对还是比较简单的不过即使是要求把这个子字符串给返回好像也不是很难记录一下最长的无重复字符的子字符串的起点和终点就行了">它只要求找出不含重复长度的最长字串的<strong><em>长度</em></strong>而已，相对还是比较简单的（不过即使是要求把这个子字符串给返回，好像也不是很难，记录一下最长的无重复字符的子字符串的起点和终点，就行了）</h2>
<h2
id="暴力做法的话就是遍历一下字符串的每个字符从左到右把每个字符都作为子字符串的起始字符看一下之后从起点开始向右遍历直至遇到重复的字符位置这个具体的判断过程在c里可以用unordered_set则记录一下此时的无重复字符的子字符串的长度和最大值比较并相应更新一下然后把起点向右移动一个字符继续重复上述判断过程">暴力做法的话，就是遍历一下字符串的每个字符，从左到右，把每个字符都作为子字符串的起始字符看一下，之后，从起点开始向右遍历，直至遇到重复的字符位置（这个具体的判断过程，在c++里可以用unordered_set），则记录一下此时的无重复字符的子字符串的长度，和最大值比较并相应更新一下。然后，把起点向右移动一个字符，继续重复上述判断过程</h2>
<h3
id="这里比较值得说一下的就是为什么滑动窗口这种做法是可以找到答案的以及为什么它会比暴力做法快暴力做法是通不过leetcode的而滑动窗口可以">这里比较值得说一下的就是，为什么滑动窗口这种做法是可以找到答案的，以及为什么它会比暴力做法快（暴力做法是通不过leetcode的，而滑动窗口可以）</h3>
<h3
id="首先暴力做法是一定能找到答案的而滑动窗口相比于暴力作出的改动也就是当我们向右移动起点的时候终点不会也随着移动而是保留在上一个的位置因此这里就省去了很多不必要的判断举个具体例子abcdaefg当我们以第一个字符为起点的时候终点移动到下一个a的时候发现重复了则计算此时不重复的子字符串的长度之后终点留在第二个a的位置我们只把起点从第一个a向右移动到b那里然后来看看现在有没有重复的字符串因为第一个字符串的终点走到了第二个a的位置才报错有重复字符说明在此之前是没有重复字符的也即abcd部分是没有重复字符的这样当我们把起点向右移动一个字符到了b那里bcd也一定是没有重复字符的没有必要回退终点就把终点停在上一轮出现重复的地方即可并且即使回退了终点判断一下确实没重复也不影响结果因为回退终点之后最长的不重复子字符串的长度一定会比上一轮的小要想比之前的大必须要做到终点不回退且起点往右移动一格没有重复后面终点还能继续往后移动且做到没有重复字符才行-这样能看出来滑动窗口之所以能找到答案是因为我们这种不回退终点只向右移动起点的方式不会漏掉最长的不重复子字符串而之所以比暴力做法优也是因为我们不回退终点省掉了很多不必要的判断">首先，暴力做法是一定能找到答案的。而滑动窗口相比于暴力，作出的改动也就是，当我们向右移动起点的时候，终点不会也随着移动，而是保留在上一个的位置。因此，这里就省去了很多不必要的判断。举个具体例子，abcdaefg，当我们以第一个字符为起点的时候，终点移动到下一个a的时候，发现重复了，则计算此时不重复的子字符串的长度，之后，终点留在第二个a的位置，我们只把起点从第一个a向右移动到b那里，然后来看看现在有没有重复的字符串。因为，第一个字符串的终点，走到了第二个a的位置，才“报错”，有重复字符，说明在此之前是没有重复字符的，也即abcd部分是没有重复字符的。这样，当我们把起点向右移动一个字符，到了b那里，bcd也一定是没有重复字符的，没有必要回退终点，就把终点停在上一轮出现重复的地方即可（并且，即使回退了终点，判断一下确实没重复，也不影响结果，因为回退终点之后，最长的不重复子字符串的长度，一定会比上一轮的小；要想比之前的大，必须要做到：终点不回退，且起点往右移动一格，没有重复，后面终点还能继续往后移动，且做到没有重复字符，才行<br>这样，能看出来，滑动窗口之所以能找到答案，是因为我们这种不回退终点，只向右移动起点的方式，不会漏掉最长的不重复子字符串；而之所以比暴力做法优，也是因为我们不回退终点，省掉了很多不必要的判断</h3>
<h1 id="代码">代码：</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 计算字符串 s 中最长无重复字符子串的长度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        std::unordered_set&lt;<span class="type">char</span>&gt; charSet;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="type">int</span> s_length = s.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (charSet.<span class="built_in">find</span>(s[j]) == charSet.<span class="built_in">end</span>() &amp;&amp; j &lt; s_length)&#123;</span><br><span class="line">                charSet.<span class="built_in">insert</span>(s[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> cur_length = j - i;</span><br><span class="line">            <span class="keyword">if</span> (cur_length &gt; res) res = cur_length;</span><br><span class="line">            charSet.<span class="built_in">erase</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="零碎知识">零碎知识：</h1>
<h2
id="这题如果用c那么判断一个字符是否出现在一个子字符串里可以用到unordered_set本题用到的操作有往集合里插入一个字符charset.insertsj判断一个字符是否在集合里出现过charset.findsj-charset.end这段代码是我们想判断字符sj是否在集合里出现过它没出现过则集合.find返回的结果会是end的迭代器即一个指向集合末尾的迭代器它表示的是集合中的最后一个元素的下一个位置也就是说如果这个等式成立就代表这个字符没有在集合里出现过如果这个字符出现过则集合.find返回的结果就会是一个指向该元素的迭代器而非charset.end">这题，如果用c++，那么，判断一个字符是否出现在一个子字符串里，可以用到unordered_set。本题用到的操作有：往集合里插入一个字符（<code>charSet.insert(s[j])</code>）、判断一个字符是否在集合里出现过（<code>charSet.find(s[j]) == charSet.end()</code>，这段代码是，我们想判断字符s[j]是否在集合里出现过。它没出现过，则集合.find()返回的结果会是end()的迭代器，即一个指向集合末尾的迭代器，它表示的是集合中的最后一个元素的下一个位置。也就是说，如果这个等式成立，就代表这个字符没有在集合里出现过。如果这个字符出现过，则集合.find()返回的结果就会是一个指向该元素的迭代器，而非charSet.end()）</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueeemouse.github.io/2025/02/15/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%8E%8C%E6%8F%A1%E7%A8%8B%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/15/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%8E%8C%E6%8F%A1%E7%A8%8B%E5%BA%A6/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-15 22:45:38" itemprop="dateCreated datePublished" datetime="2025-02-15T22:45:38+08:00">2025-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-01 16:50:48" itemprop="dateModified" datetime="2025-05-01T16:50:48+08:00">2025-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>快排还是不熟，没彻底弄懂，chap1第一讲中的其它内容倒是差不多搞懂了 #
chap1 ## 快排 5（边界条件还是没彻底掌握） ## 归并排序 ## 二分查找 ##
高精度 ## 前缀和 ## 差分 ## 双指针 ## 位运算 ## 离散化 # chap2 ##
链表（单链表3，双链表3） ## 栈与队列 ## kmp ## trie树 2 ## 并查集 ## 堆
##</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueeemouse.github.io/2025/02/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap1.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E5%BF%AB%E6%8E%92&%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap1.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E5%BF%AB%E6%8E%92&%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">chap1.第一讲 快排&归并排序&二分查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-04 16:00:00" itemprop="dateCreated datePublished" datetime="2025-02-04T16:00:00+08:00">2025-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-13 21:15:25" itemprop="dateModified" datetime="2025-04-13T21:15:25+08:00">2025-04-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algo/" itemprop="url" rel="index"><span itemprop="name">algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="快速排序">1.快速排序</h1>
<h2 id="核心思想分治思想">1.1.核心思想：分治思想</h2>
<h2 id="步骤">1.2.步骤：</h2>
<h3
id="对于一个给定的数组选定一个中间值x理论上来说选哪个都行但后面的代码需要注意相应的搭配否则会陷入死循环后面具体讲常见的就是选数组的左边右边中间值随机选">1.2.1.对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边/右边/中间值/随机选</h3>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/02/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap1.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E5%BF%AB%E6%8E%92&%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueeemouse.github.io/2025/02/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap1.%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E9%AB%98%E7%B2%BE%E5%BA%A6&%E5%89%8D%E7%BC%80%E5%92%8C&%E5%B7%AE%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap1.%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E9%AB%98%E7%B2%BE%E5%BA%A6&%E5%89%8D%E7%BC%80%E5%92%8C&%E5%B7%AE%E5%88%86/" class="post-title-link" itemprop="url">chap1.第二讲 高精度&前缀和&差分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-04 16:00:00" itemprop="dateCreated datePublished" datetime="2025-02-04T16:00:00+08:00">2025-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-16 17:04:46" itemprop="dateModified" datetime="2025-02-16T17:04:46+08:00">2025-02-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algo/" itemprop="url" rel="index"><span itemprop="name">algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高精度">1.高精度</h1>
<h2 id="简介">1.1.简介</h2>
<h3
id="所谓高精度在这里指的是大数相关的运算且不是每一种语言都需要自己实现这种算法像java和python就不需要大体上是因为它们已经自带这个功能了而算法常用的cc则没有这种功能因此需要自己实现-而这门课讲的高精度主要局限在两个大数相加相减以及一个大数乘以一个小数这里的大数一般指位数很多的正整数lenaleq-1e6小数一般指位数不那么多的正整数lenbleq-9">所谓高精度，在这里指的是大数相关的运算。且不是每一种语言都需要自己实现这种算法。像java和python就不需要（大体上是因为它们已经自带这个功能了）。而算法常用的c/c++则没有这种功能，因此需要自己实现<br>而这门课讲的高精度，主要局限在两个大数相加/相减，以及一个大数乘以一个小数（这里的大数，一般指位数很多的正整数，<span
class="math inline">\(len(A)\leq
1e6\)</span>；小数一般指位数不那么多的正整数，<span
class="math inline">\(len(B)\leq 9\)</span>）</h3>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/02/04/algo/%E5%9F%BA%E7%A1%80%E8%AF%BE/chap1.%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E9%AB%98%E7%B2%BE%E5%BA%A6&%E5%89%8D%E7%BC%80%E5%92%8C&%E5%B7%AE%E5%88%86/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueeemouse.github.io/2025/02/03/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/03/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-03 17:28:21" itemprop="dateCreated datePublished" datetime="2025-02-03T17:28:21+08:00">2025-02-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bluemouse</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bluemouse</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
